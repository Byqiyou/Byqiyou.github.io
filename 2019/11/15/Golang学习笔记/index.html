<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Golang学习笔记 | 七友</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Golang">
    <meta name="description" content="Golang学习笔记你的 Go 安装目录（$GOROOT）的文件夹结构应该如下所示： 1234567/bin：包含可执行文件，如：编译器，Go 工具/doc：包含示例程序，代码工具，本地文档等/lib：包含文档模版/misc：包含与支持 Go 编辑器有关的配置文件以及 cgo 的示例/os_arch：包含标准库的包的对象文件（.a）/src：包含源代码构建脚本和标准库的包的完整源代码（Go 是一门">
<meta name="keywords" content="Golang">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang学习笔记">
<meta property="og:url" content="https://byqiyou.github.io/2019/11/15/Golang学习笔记/index.html">
<meta property="og:site_name" content="七友">
<meta property="og:description" content="Golang学习笔记你的 Go 安装目录（$GOROOT）的文件夹结构应该如下所示： 1234567/bin：包含可执行文件，如：编译器，Go 工具/doc：包含示例程序，代码工具，本地文档等/lib：包含文档模版/misc：包含与支持 Go 编辑器有关的配置文件以及 cgo 的示例/os_arch：包含标准库的包的对象文件（.a）/src：包含源代码构建脚本和标准库的包的完整源代码（Go 是一门">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-12-22T14:26:45.048Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Golang学习笔记">
<meta name="twitter:description" content="Golang学习笔记你的 Go 安装目录（$GOROOT）的文件夹结构应该如下所示： 1234567/bin：包含可执行文件，如：编译器，Go 工具/doc：包含示例程序，代码工具，本地文档等/lib：包含文档模版/misc：包含与支持 Go 编辑器有关的配置文件以及 cgo 的示例/os_arch：包含标准库的包的对象文件（.a）/src：包含源代码构建脚本和标准库的包的完整源代码（Go 是一门">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname"></h5>
          <a href="mailto:hack2fun@foxmail.com" title="hack2fun@foxmail.com" class="mail">hack2fun@foxmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/byqiyou" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/friends"  >
                <i class="icon icon-lg icon-friends"></i>
                Friends
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-about"></i>
                About
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Golang学习笔记</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Golang学习笔记</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-11-15T07:30:18.000Z" itemprop="datePublished" class="page-time">
  2019-11-15
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Golang学习笔记"><span class="post-toc-number">1.</span> <span class="post-toc-text">Golang学习笔记</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数据类型"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">数据类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#变量"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">变量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#常量"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">常量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#运算符"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">运算符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#条件"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">条件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类型转换"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">类型转换</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#指针"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">指针</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Go语言type关键字（类型别名）"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">Go语言type关键字（类型别名）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#结构体"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">结构体</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实例化的方法"><span class="post-toc-number">1.9.1.</span> <span class="post-toc-text">实例化的方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#成员赋值"><span class="post-toc-number">1.9.2.</span> <span class="post-toc-text">成员赋值</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#接收器"><span class="post-toc-number">1.9.3.</span> <span class="post-toc-text">接收器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Go语言类型内嵌和结构体内嵌"><span class="post-toc-number">1.9.4.</span> <span class="post-toc-text">Go语言类型内嵌和结构体内嵌</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#结构体内嵌模拟类的继承"><span class="post-toc-number">1.9.5.</span> <span class="post-toc-text">结构体内嵌模拟类的继承</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#初始化内嵌结构体"><span class="post-toc-number">1.9.6.</span> <span class="post-toc-text">初始化内嵌结构体</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#map"><span class="post-toc-number">1.10.</span> <span class="post-toc-text">map</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#sync-Map"><span class="post-toc-number">1.11.</span> <span class="post-toc-text">sync.Map</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组"><span class="post-toc-number">1.12.</span> <span class="post-toc-text">数组</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#切片"><span class="post-toc-number">1.13.</span> <span class="post-toc-text">切片</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#list"><span class="post-toc-number">1.14.</span> <span class="post-toc-text">list</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#nil"><span class="post-toc-number">1.15.</span> <span class="post-toc-text">nil</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#if"><span class="post-toc-number">1.16.</span> <span class="post-toc-text">if</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#for"><span class="post-toc-number">1.17.</span> <span class="post-toc-text">for</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#函数"><span class="post-toc-number">1.18.</span> <span class="post-toc-text">函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#接口"><span class="post-toc-number">1.19.</span> <span class="post-toc-text">接口</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#包"><span class="post-toc-number">1.20.</span> <span class="post-toc-text">包</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#package语句"><span class="post-toc-number">1.20.1.</span> <span class="post-toc-text">package语句</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#导入自定义包"><span class="post-toc-number">1.20.1.1.</span> <span class="post-toc-text">导入自定义包</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#import语句"><span class="post-toc-number">1.20.2.</span> <span class="post-toc-text">import语句</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#导入匿名包"><span class="post-toc-number">1.20.2.1.</span> <span class="post-toc-text">导入匿名包</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#io"><span class="post-toc-number">1.21.</span> <span class="post-toc-text">io</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ReadBytes-方法"><span class="post-toc-number">1.22.</span> <span class="post-toc-text">ReadBytes() 方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#接口-1"><span class="post-toc-number">1.23.</span> <span class="post-toc-text">接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#接口被实现的条件一：接口的方法与实现接口的类型方法格式一致"><span class="post-toc-number">1.23.1.</span> <span class="post-toc-text">接口被实现的条件一：接口的方法与实现接口的类型方法格式一致</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#接口被实现的条件二：接口中所有方法均被实现"><span class="post-toc-number">1.23.2.</span> <span class="post-toc-text">接口被实现的条件二：接口中所有方法均被实现</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多个类型可以实现相同的接口"><span class="post-toc-number">1.23.3.</span> <span class="post-toc-text">多个类型可以实现相同的接口</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#goland的常见标准库"><span class="post-toc-number">2.</span> <span class="post-toc-text">goland的常见标准库</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#strings"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">strings</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#time"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">time</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#fmt"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">fmt</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#math-big"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">math/big</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#os包"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">os包</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#os-exec"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">os/exec</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#log"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">log</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#regexp"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">regexp</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#encoding"><span class="post-toc-number">2.9.</span> <span class="post-toc-text">encoding</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#encoding-hex"><span class="post-toc-number">2.9.1.</span> <span class="post-toc-text">encoding/hex</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#encoding-base64"><span class="post-toc-number">2.9.2.</span> <span class="post-toc-text">encoding/base64</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#crypto"><span class="post-toc-number">2.10.</span> <span class="post-toc-text">crypto</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#crypto-md5"><span class="post-toc-number">2.10.1.</span> <span class="post-toc-text">crypto/md5</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#crypto-sha256"><span class="post-toc-number">2.10.2.</span> <span class="post-toc-text">crypto/sha256</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#crypto-sha512"><span class="post-toc-number">2.10.3.</span> <span class="post-toc-text">crypto/sha512</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#crypto-rand"><span class="post-toc-number">2.10.4.</span> <span class="post-toc-text">crypto/rand</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#crypto-aes"><span class="post-toc-number">2.10.5.</span> <span class="post-toc-text">crypto/aes</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#crypto-des"><span class="post-toc-number">2.10.6.</span> <span class="post-toc-text">crypto/des</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#crypto-hmac"><span class="post-toc-number">2.10.7.</span> <span class="post-toc-text">crypto/hmac</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#hash"><span class="post-toc-number">2.11.</span> <span class="post-toc-text">hash</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#hash-crc32"><span class="post-toc-number">2.11.1.</span> <span class="post-toc-text">hash/crc32</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#reflect"><span class="post-toc-number">2.12.</span> <span class="post-toc-text">reflect</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#从实例到-Value"><span class="post-toc-number">2.12.1.</span> <span class="post-toc-text">从实例到 Value</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#从实例到-Type"><span class="post-toc-number">2.12.2.</span> <span class="post-toc-text">从实例到 Type</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#从Value到实例"><span class="post-toc-number">2.12.3.</span> <span class="post-toc-text">从Value到实例</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#从-Value-到-Type"><span class="post-toc-number">2.12.4.</span> <span class="post-toc-text">从 Value 到 Type</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#从-Value-的指针到值"><span class="post-toc-number">2.12.5.</span> <span class="post-toc-text">从 Value 的指针到值</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Value-值的可修改性"><span class="post-toc-number">2.12.6.</span> <span class="post-toc-text">Value 值的可修改性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实例"><span class="post-toc-number">2.12.7.</span> <span class="post-toc-text">实例</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Name和Kind的区别"><span class="post-toc-number">2.12.8.</span> <span class="post-toc-text">Name和Kind的区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#通过反射获取指针指向的元素类型"><span class="post-toc-number">2.12.9.</span> <span class="post-toc-text">通过反射获取指针指向的元素类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#结构体标签"><span class="post-toc-number">2.12.10.</span> <span class="post-toc-text">结构体标签</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#通过反射获取值信息"><span class="post-toc-number">2.12.11.</span> <span class="post-toc-text">通过反射获取值信息</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#通过反射访问结构体成员的值"><span class="post-toc-number">2.12.12.</span> <span class="post-toc-text">通过反射访问结构体成员的值</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#判断反射值的空和有效性"><span class="post-toc-number">2.12.13.</span> <span class="post-toc-text">判断反射值的空和有效性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#通过反射修改变量的值"><span class="post-toc-number">2.12.14.</span> <span class="post-toc-text">通过反射修改变量的值</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#通过反射调用函数"><span class="post-toc-number">2.12.15.</span> <span class="post-toc-text">通过反射调用函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#并发"><span class="post-toc-number">2.13.</span> <span class="post-toc-text">并发</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#活锁、死锁、饥饿"><span class="post-toc-number">3.</span> <span class="post-toc-text">活锁、死锁、饥饿</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#死锁"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">死锁</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一些杂项"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">一些杂项</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#生成二维码"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">生成二维码</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Golang学习笔记"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Golang学习笔记</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-11-15 15:30:18" datetime="2019-11-15T07:30:18.000Z"  itemprop="datePublished">2019-11-15</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="Golang学习笔记"><a href="#Golang学习笔记" class="headerlink" title="Golang学习笔记"></a>Golang学习笔记</h2><p>你的 Go 安装目录<code>（$GOROOT）</code>的文件夹结构应该如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/bin：包含可执行文件，如：编译器，Go 工具</span><br><span class="line">/doc：包含示例程序，代码工具，本地文档等</span><br><span class="line">/lib：包含文档模版</span><br><span class="line">/misc：包含与支持 Go 编辑器有关的配置文件以及 cgo 的示例</span><br><span class="line">/os_arch：包含标准库的包的对象文件（.a）</span><br><span class="line">/src：包含源代码构建脚本和标准库的包的完整源代码（Go 是一门开源语言）</span><br><span class="line">/src/cmd：包含 Go 和 C 的编译器和命令行脚本</span><br></pre></td></tr></tbody></table></figure>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这些浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 math 包中找到：</span><br><span class="line">常量 math.MaxFloat32 表示 float32 能取到的最大数值，大约是 3.4e38；</span><br><span class="line">常量 math.MaxFloat64 表示 float64 能取到的最大数值，大约是 1.8e308；</span><br><span class="line">float32 和 float64 能表示的最小值分别为 1.4e-45 和 4.9e-324。</span><br><span class="line">一个 float32 类型的浮点数可以提供大约 6 个十进制数的精度，而 float64 则可以提供约 15 个十进制数的精度，通常应该优先使用 float64 类型，因为 float32 类型的累计计算误差很容易扩散，并且 float32 能精确表示的正整数并不是很大。</span><br></pre></td></tr></tbody></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 变量如果只声明没有赋值，则默认值为0，bool型是false，字符型是""</span><br><span class="line">2. =:  (1)不能在函数体外面复制，这样会报错。(2)=:声明的变量不能用var声明，而且这个变量是没有被声明过的</span><br><span class="line">3. 变量被声明了之后必须被使用，不然就会报错</span><br><span class="line">4. 下划线也被称为空白标识符，例如：var _ , a=1,2中的1会被抛弃，空白标识符经常在函数返回值中使用</span><br><span class="line">5. 同时声明多个变量，var a,b,c=1,2,3 //其中不用标明变量类型，这一点和python很像</span><br><span class="line">6. 交换两个变量的值时候要注意类型要相同，a,b=b,a</span><br><span class="line">7. 变量还可以使用枚举的方式声明	var(</span><br><span class="line">                            		name="qiyou"</span><br><span class="line">                            		age=10</span><br><span class="line">                            	)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</span><br><span class="line">2. 声明格式：const identifier [type] = value //你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。</span><br><span class="line">3. 常量声明之后不使用也可以</span><br><span class="line">4. 常量还可以使用枚举的方式声明	const(</span><br><span class="line">                            		NAME="qiyou"</span><br><span class="line">                            		AGE=10</span><br><span class="line">                            	)</span><br><span class="line">5. 同时声明多个常量：const NAME,AGE="QIYOU",1</span><br><span class="line">6. 在定义常量组时，如果不提供初始值，则表示将使用上行的表达式（只适用于枚举的情况下）。</span><br><span class="line">	const(</span><br><span class="line">		a=1</span><br><span class="line">		b</span><br><span class="line">	)</span><br><span class="line">	fmt.Println(a,b) //输出1 1</span><br></pre></td></tr></tbody></table></figure>
<p>iota<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">	const(</span><br><span class="line">		a=iota //a=0</span><br><span class="line">		b		//b=1</span><br><span class="line">		c		//c=2</span><br><span class="line">		d		//d=3</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">如果想忽略中间一个量则可以使用</span><br><span class="line">	const(</span><br><span class="line">		a=iota //a=0</span><br><span class="line">		b		//b=1</span><br><span class="line">		c		//c=2</span><br><span class="line">		d		//d=3</span><br><span class="line">		_</span><br><span class="line">		e		//e=5</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">乘法实例</span><br><span class="line">	const(</span><br><span class="line">		a=2*iota //2*0</span><br><span class="line">		b        //2*1</span><br><span class="line">		c        //2*2</span><br><span class="line">		d        //2*3</span><br><span class="line">		e        //2*4</span><br><span class="line">		f="test" //注意这里iota变成了5</span><br><span class="line">		g=2*iota  //2*6</span><br><span class="line">	)</span><br><span class="line">	fmt.Println(a,b,c,d,e,g)</span><br><span class="line"></span><br><span class="line">iota 只是在同一个 const 常量组内递增，每当有新的 const 关键字时，iota 计数会重新开始。</span><br><span class="line">    const (</span><br><span class="line">        i = iota</span><br><span class="line">        j = iota</span><br><span class="line">        x = iota</span><br><span class="line">    )</span><br><span class="line">    const xx = iota</span><br><span class="line">    const yy = iota</span><br><span class="line">    func main(){</span><br><span class="line">        println(i, j, x, xx, yy)</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    // 输出是 0 1 2 0 0</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+	相加	A + B 输出结果 30</span><br><span class="line">-	相减	A - B 输出结果 -10</span><br><span class="line">*	相乘	A * B 输出结果 200</span><br><span class="line">/	相除	B / A 输出结果 2</span><br><span class="line">%	求余	B % A 输出结果 0</span><br><span class="line">++	自增	A++ 输出结果 11</span><br><span class="line">--	自减	A-- 输出结果 9</span><br><span class="line"></span><br><span class="line">&amp;&amp;	逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。	(A &amp;&amp; B) 为 False</span><br><span class="line">||	逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。	(A || B) 为 True</span><br><span class="line">!	逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。	!(A &amp;&amp; B) 为 True</span><br></pre></td></tr></tbody></table></figure>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>case<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 注意多个case是不能出现相同的值的，否则会报错</span><br><span class="line">2. 可以在一个 case 中包含多个表达式，每个表达式用逗号分隔。</span><br><span class="line">3. 没有表达式的 switch,则相当于 switch true，这种情况下会将每一个 case 的表达式的求值结果与 true 做比较，如果相等，则执行相应的代码。</span><br><span class="line">4. fallthrough语句用于标明执行完当前 case 语句之后按顺序执行下一个case 语句。</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于Go语言不存在隐式类型转换，因此所有的类型转换都必须显式的声明</span><br><span class="line"></span><br><span class="line">2. bool型不能转换位int型，相反int型也不能转换成bool型</span><br><span class="line"></span><br><span class="line">3.</span><br></pre></td></tr></tbody></table></figure>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. new() 函数可以创建一个对应类型的指针，创建过程会分配内存，被创建的指针指向默认值。</span><br><span class="line"></span><br><span class="line">2. %p表示输出指针地址</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Go语言type关键字（类型别名）"><a href="#Go语言type关键字（类型别名）" class="headerlink" title="Go语言type关键字（类型别名）"></a>Go语言type关键字（类型别名）</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type NewType = Type //定义别名</span><br><span class="line">type NewType Type //定义一个类型</span><br></pre></td></tr></tbody></table></figure>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><h4 id="实例化的方法"><a href="#实例化的方法" class="headerlink" title="实例化的方法"></a>实例化的方法</h4><ol>
<li><p>用var实例化</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 结构体本身也是一种类型，可以用var实例化：var name T</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>创建指针类型的结构体</p>
</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：ins := new(T)</span><br><span class="line"></span><br><span class="line">T 为类型，可以是结构体、整型、字符串等。</span><br><span class="line">ins：T 类型被实例化后保存到 ins 变量中，ins 的类型为 *T，属于指针。</span><br></pre></td></tr></tbody></table></figure>
<ol start="3">
<li>取结构体的地址实例化<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在Go语言中，对结构体进行&amp;取地址操作时，视为对该类型进行一次 new 的实例化操作，取地址格式为：ins := &amp;T{}</span><br><span class="line">带传值的：ins:=&amp;person{name: name,age: age,nickname: nickname}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<h4 id="成员赋值"><a href="#成员赋值" class="headerlink" title="成员赋值"></a>成员赋值</h4><ol>
<li><p>结构体实例化后字段的默认值是字段类型的默认值，例如 ，数值为 0、字符串为 “”（空字符串）、布尔为 false、指针为 nil 等。</p>
</li>
<li><p>使用多个值的列表初始化结构体</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">必须初始化结构体的所有字段。</span><br><span class="line">每一个初始值的填充顺序必须与字段在结构体中的声明顺序一致。</span><br><span class="line">键值对与值列表的初始化形式不能混用。</span><br><span class="line"></span><br><span class="line">type Address struct {</span><br><span class="line">    Province    string</span><br><span class="line">    City        string</span><br><span class="line">    ZipCode     int</span><br><span class="line">    PhoneNumber string</span><br><span class="line">}</span><br><span class="line">addr := Address{</span><br><span class="line">    "四川",</span><br><span class="line">    "成都",</span><br><span class="line">    610000,</span><br><span class="line">    "0",</span><br><span class="line">}</span><br><span class="line">fmt.Println(addr)</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针结构体，成员可以直接使用.号访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>{</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	weigth <span class="keyword">int</span></span><br><span class="line">	nickname <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">var</span> lisi person</span><br><span class="line">	lisi.name=<span class="string">"lisi"</span></span><br><span class="line">	changename(&amp;lisi)</span><br><span class="line">	fmt.Println(lisi.name)</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changename</span><span class="params">(pname *person)</span></span>{</span><br><span class="line">	pname.name=<span class="string">"qiyou"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="接收器"><a href="#接收器" class="headerlink" title="接收器"></a>接收器</h4><p>接收器的格式如下：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) {</span><br><span class="line">    函数体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>指针类型的接收器<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type person struct{</span><br><span class="line">    name string</span><br><span class="line">    age uint</span><br><span class="line">    nickname string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main(){</span><br><span class="line">    lisi:=&amp;person{}</span><br><span class="line">    lisi.setValue("lisi")</span><br><span class="line">    fmt.Println(lisi.getValue())</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (p *person)setValue(v string){</span><br><span class="line">    p.name=v</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (p *person)getValue() string{</span><br><span class="line">    return p.name</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h4 id="Go语言类型内嵌和结构体内嵌"><a href="#Go语言类型内嵌和结构体内嵌" class="headerlink" title="Go语言类型内嵌和结构体内嵌"></a>Go语言类型内嵌和结构体内嵌</h4><ol>
<li>在一个结构体中对于每一种数据类型只能有一个匿名字段。</li>
<li><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func main()  {</span><br><span class="line">    type inn struct{</span><br><span class="line">        name string</span><br><span class="line">    }</span><br><span class="line">    type test struct{</span><br><span class="line">        nickname string</span><br><span class="line">        name string</span><br><span class="line">        int</span><br><span class="line">        inn</span><br><span class="line">    }</span><br><span class="line">    abc:=&amp;test{}</span><br><span class="line">    abc.nickname="zhangsan"</span><br><span class="line">    abc.inn.name="lisi" //另外一种访问方式：abc.name="lisi"，前提test这个结构体没有name这个成员</span><br><span class="line">    abc.int=1           //直接使用abc.int访问匿名变量，不过每一种类型的匿名变量只能有一个</span><br><span class="line">    fmt.Println(abc.inn.name) //也可以abc.name，前提test这个结构体没有name这个成员</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<h4 id="结构体内嵌模拟类的继承"><a href="#结构体内嵌模拟类的继承" class="headerlink" title="结构体内嵌模拟类的继承"></a>结构体内嵌模拟类的继承</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">type Walkable struct{}</span><br><span class="line">type Fly struct{}</span><br><span class="line"></span><br><span class="line">func (f *Fly) IsFly(){</span><br><span class="line">    fmt.Println("I can fly!")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func (w * Walkable)IsWalk(){</span><br><span class="line">    fmt.Println("I can Walk!")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type bird struct{</span><br><span class="line">    Walkable</span><br><span class="line">    Fly</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type human struct{</span><br><span class="line">    Walkable</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main()  {</span><br><span class="line">    b:=new(bird)</span><br><span class="line">    b.IsFly() //或者 b.Fly.IsFly()</span><br><span class="line">    b.IsWalk() //或者 b.Walkable.IsWalk()</span><br><span class="line">    h:=new(human)</span><br><span class="line">    h.IsWalk()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="初始化内嵌结构体"><a href="#初始化内嵌结构体" class="headerlink" title="初始化内嵌结构体"></a>初始化内嵌结构体</h4><p>例子一：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type computer struct{</span><br><span class="line">    cpu string</span><br><span class="line">    RAM uint</span><br><span class="line">    ROM uint</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main()  {</span><br><span class="line">    lianxiang:=computer{</span><br><span class="line">        cpu:"Intel",</span><br><span class="line">        RAM:8,</span><br><span class="line">        ROM:1000, //注意最后要有逗号，不然就会报错</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(lianxiang)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>例子二：<br>有时考虑编写代码的便利性，会将结构体直接定义在嵌入的结构体中。也就是说，结构体的定义不会被外部引用到。在初始化这个被嵌入的结构体时，就需要再次声明结构才能赋予数据。<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type computer struct{</span><br><span class="line">    cpu string</span><br><span class="line">    RAM uint</span><br><span class="line">    ROM struct{</span><br><span class="line">        size uint</span><br><span class="line">        brand string</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main()  {</span><br><span class="line">    lianxiang:=computer{</span><br><span class="line">        cpu: "Intel",</span><br><span class="line">        RAM: 8,</span><br><span class="line">        ROM: struct{</span><br><span class="line">            size uint</span><br><span class="line">            brand string</span><br><span class="line">        }{</span><br><span class="line">            size: 1000,</span><br><span class="line">            brand: "Kingston",</span><br><span class="line">        },  //注意这里要有逗号，不然就会报错</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(lianxiang)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* 声明变量，默认 map 是 nil */</span><br><span class="line">var map_variable map[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line">/* 使用 make 函数 */</span><br><span class="line">map_variable := make(map[key_data_type]value_data_type)</span><br><span class="line"></span><br><span class="line">声明：  var person map[string]string    //map为nil，可以通过这种形式来添加键值对：person = map[string]string{"name":"qiyou"}</span><br><span class="line">        var person =map[string]string{} //注意后面有一个{}，map不是nil</span><br><span class="line">        var person = make(map[string]string)</span><br><span class="line"></span><br><span class="line">如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</span><br><span class="line"></span><br><span class="line">2. delete函数用于删除一个集合中的元素：</span><br><span class="line">                                      delete(person,"name")</span><br><span class="line"></span><br><span class="line">3. 一个可以对应多个值我们可以用切片来解决：</span><br><span class="line">                                    	m1:=make(map[string][]int)</span><br><span class="line">                                        m1["name"]=[]int {1,1,2,1}</span><br><span class="line">                                        fmt.Println(m1["name"])</span><br><span class="line">4. map的遍历我们可以用for range</span><br><span class="line"></span><br><span class="line">5. go没有提供清空map的函数，所以清空map的方法是重新make一个map</span><br></pre></td></tr></tbody></table></figure>
<h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><blockquote>
<p>Go中的 map 在并发情况下，只读是线程安全的，同时读写是线程不安全的。所以就有了sync.Map</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. sync.Map 和 map 不同，不是以语言原生形态提供，而是在 sync 包下的特殊结构。</span><br><span class="line">2. sync.Map 有以下特性：</span><br><span class="line">        无须初始化，直接声明即可。</span><br><span class="line">        sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用，Store 表示存储，Load表示获取，Delete 表示删除。</span><br><span class="line">        使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，Range参数中回调函数的返回值在需要继续迭代遍历时，返回 true；终止迭代遍历时，返回 false。</span><br><span class="line">3. sync.Map的键类型和值类型不一定必须相同</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">      "fmt"</span><br><span class="line">      "sync"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">    var scene sync.Map</span><br><span class="line">    // 将键值对保存到sync.Map</span><br><span class="line">    scene.Store("greece", 97)</span><br><span class="line">    scene.Store("london", 100)</span><br><span class="line">    scene.Store("egypt", 200)</span><br><span class="line">    // 从sync.Map中根据键取值</span><br><span class="line">    fmt.Println(scene.Load("london"))</span><br><span class="line">    // 根据键删除对应的键值对</span><br><span class="line">    scene.Delete("london")</span><br><span class="line">    // 遍历所有sync.Map中的键值对</span><br><span class="line">    scene.Range(func(k, v interface{}) bool {</span><br><span class="line">        fmt.Println("iterate:", k, v)</span><br><span class="line">        return true</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:=[...]int {1,1,1,1} //最终长度为4</span><br></pre></td></tr></tbody></table></figure>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><blockquote>
<p>切片并不存储任何元素而只是对现有数组的引用。</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">从数组或切片生成新的切片拥有如下特性：</span><br><span class="line">取出的元素数量为：结束位置 - 开始位置；</span><br><span class="line">取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取；</span><br><span class="line">当缺省开始位置时，表示从连续区域开头到结束位置；</span><br><span class="line">当缺省结束位置时，表示从开始位置到整个连续区域末尾；</span><br><span class="line">两者同时缺省时，与切片本身等效；//a[:]</span><br><span class="line">两者同时为 0 时，等效于空切片，一般用于切片复位。 //a[0:0]</span><br><span class="line"></span><br><span class="line">切片和数组的区别就是：切片是引用，而数组是值传递</span><br><span class="line"></span><br><span class="line">切片的长度和容量：</span><br><span class="line">    切片的长度是指切片中元素的个数。切片的容量是指从切片的起始元素开始到其底层数组中的最后一个元素的个数。</span><br></pre></td></tr></tbody></table></figure>
<p>append<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">append只能用于操作切片，不能用于操作数组</span><br><span class="line">当新元素通过调用 append 函数追加到切片末尾时，如果超出了容量，append 内部会创建一个新的数组。并将原有数组的元素被拷贝给这个新的数组，最后返回建立在这个新数组上的切片。这个新切片的容量是旧切片的二倍</span><br><span class="line">append的返回值是添加后的切片</span><br></pre></td></tr></tbody></table></figure><p></p>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a= []<span class="keyword">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}</span><br><span class="line"><span class="keyword">var</span> b =a[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> x,_:=<span class="keyword">range</span> b{</span><br><span class="line">	b[x]++</span><br><span class="line">}</span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="comment">//注意切片是对数组的引用，而不是传递值，所有a输出的是[1 3 3]</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><blockquote>
<p>不是go内置的，要导入包container/list</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. list 的初始化有两种方法：分别是使用 New() 函数和 var 关键字声明，两种方法的初始化效果都是一致的。</span><br><span class="line">    1) 通过 container/list 包的 New() 函数初始化 list</span><br><span class="line">        变量名 := list.New()</span><br><span class="line"></span><br><span class="line">    2) 通过 var 关键字声明初始化 list</span><br><span class="line">        var 变量名 list.List</span><br></pre></td></tr></tbody></table></figure>
<p>函数<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. mylist.Len() 返回链表的长度</span><br><span class="line">2. mylist.init() 初始化链表，即清空链表</span><br><span class="line">3. PushBack在列表mylist的后面插入一个值为v的新元素e并返回e。</span><br><span class="line">4. PushFront在列表mylist的前面插入一个值为v的新元素e并返回e。</span><br><span class="line">5. Next返回下一个list元素或nil</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>例子<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">l := list.New()</span><br><span class="line"> <span class="comment">// 尾部添加</span></span><br><span class="line"> l.PushBack(<span class="string">"canon"</span>)</span><br><span class="line"> <span class="comment">// 头部添加</span></span><br><span class="line"> l.PushFront(<span class="number">67</span>)</span><br><span class="line"> <span class="comment">// 尾部添加后保存元素句柄</span></span><br><span class="line"> element := l.PushBack(<span class="string">"fist"</span>)</span><br><span class="line"> <span class="comment">// 在fist之后添加high</span></span><br><span class="line"> l.InsertAfter(<span class="string">"high"</span>, element) </span><br><span class="line"> <span class="comment">// 在fist之前添加noon</span></span><br><span class="line"> l.InsertBefore(<span class="string">"noon"</span>, element)</span><br><span class="line"> <span class="comment">// 使用</span></span><br><span class="line"> l.Remove(element) <span class="comment">//删除fist这个元素</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>遍历所有链表<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i:=mylist.Front();i!=nil;i=i.Next(){</span><br><span class="line">	fmt.Println(i.Value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h3><p>nil 是 map、slice、pointer、channel、func、interface 的零值</p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><ol>
<li>if左边的括号必须要和if在同一行</li>
<li></li>
</ol>
<p>if 还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，代码如下：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if err := Connect(); err != nil {</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    return</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>break退出指定循环，一个标签只能对应一个循环<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">out:</span><br><span class="line">	for i:=1;;i++{</span><br><span class="line">		if i&gt;9{</span><br><span class="line">			break out</span><br><span class="line">		}else{</span><br><span class="line">			fmt.Println("test")</span><br><span class="line">		}</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>continue 语句可以结束当前循环，开始下一次的循环迭代过程，仅限在 for 循环内使用，在 continue 语句后添加标签时，表示开始标签对应的循环</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OuterLoop:</span><br><span class="line">    for i := 0; i &lt; 2; i++ {</span><br><span class="line">        for j := 0; j &lt; 5; j++ {</span><br><span class="line">            switch j {</span><br><span class="line">            case 2:</span><br><span class="line">                fmt.Println(i, j)</span><br><span class="line">                continue OuterLoop //表示结束当前循环，开启下一次的外层循环，而不是第 10 行的循环。</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">输出：0 2</span><br><span class="line">      1 2</span><br></pre></td></tr></tbody></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol>
<li><p>在函数中，实参通过值传递的方式进行传递，因此函数的形参是实参的拷贝，对形参进行修改不会影响实参，但是，如果实参包括引用类型，如指针、slice(切片)、map、function、channel 等类型，实参可能会由于函数的间接引用被修改。</p>
</li>
<li><p>在Go语言中，函数也是一种类型，可以和其他类型一样保存在变量中,下面的代码定义了一个函数变量 f，并将一个函数名为 echo() 的函数赋给函数变量 f，这样调用函数变量 f 时，实际调用的就是 echo() 函数，代码如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main(){</span><br><span class="line">	var f func(string)</span><br><span class="line">	f=echo</span><br><span class="line">	f("test")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func echo(s string)  {</span><br><span class="line">	a:=s</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>宕机</p>
</li>
</ol>
<p>发生宕机时后面的代码都不会执行，注意一点就是defer如果在发生宕机前面的话，还是正常执行的<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main(){</span><br><span class="line">	defer fmt.Println("a")</span><br><span class="line">	defer fmt.Println("b")</span><br><span class="line">	panic("Done!")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">b</span><br><span class="line">a</span><br><span class="line">panic: Done!</span><br></pre></td></tr></tbody></table></figure><p></p>
<ol start="4">
<li>宕机恢复recover</li>
</ol>
<p>一旦发生宕机，其后的代码是不会执行的，但是会调用位于panic代码所在的哪一行之前的defer延迟函数，所以说这个特性就决定recover应该用在defer函数中，否则一旦发生宕机，除了defer延迟函数中的语句还能执行外，其他的语句都是不能执行的。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">	fmt.Println("Begin!")</span><br><span class="line">	defer func() {</span><br><span class="line">		if err := recover(); err != nil {</span><br><span class="line">			fmt.Println("error: ", err)</span><br><span class="line">		}</span><br><span class="line">	}()</span><br><span class="line">	var a *int</span><br><span class="line">	*a = 1 //空指针的引用，会发生宕机</span><br><span class="line">	fmt.Println("Not end!")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Begin!</span><br><span class="line">error:  runtime error: invalid memory address or nil pointer dereference</span><br></pre></td></tr></tbody></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>每个接口类型由<strong>数个方法</strong>组成。接口的形式代码如下：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">接口声明的格式</span><br><span class="line">type 接口类型名 interface{</span><br><span class="line">    方法名1( 参数列表1 ) 返回值列表1</span><br><span class="line">    方法名2( 参数列表2 ) 返回值列表2</span><br><span class="line">    …</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>对各个部分的说明：</p>
<ol>
<li>接口类型名：使用 type 将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加 er，如有写操作的接口叫 Writer，有字符串功能的接口叫 Stringer，有关闭功能的接口叫 Closer 等。</li>
<li>方法名：当方法名首字母是大写时，且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。<br>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以被忽略，例如：<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type writer interface{</span><br><span class="line">    Write([]byte) error</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><h4 id="package语句"><a href="#package语句" class="headerlink" title="package语句"></a>package语句</h4><ol>
<li>要想使用自定义的包中的函数、变量、结构体，则首字母必须要大写（即public），如果首字母是小写则外部包访问（即private）</li>
</ol>
<h5 id="导入自定义包"><a href="#导入自定义包" class="headerlink" title="导入自定义包"></a>导入自定义包</h5><ol>
<li>import后面是文件夹名称</li>
<li>文件夹名称和package名称不一定要相同</li>
<li>调用自定义包中的函数使用<code>packeage.func()</code>来调用</li>
<li>自定义包的调用和文件名<strong>没有关系</strong>，只与文件中的<code>package</code>语句有关，go会自动查找import文件夹里面的所有文件，然后查找所有package，不同的go文件可以有相同的package名称</li>
</ol>
<h4 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h4><h5 id="导入匿名包"><a href="#导入匿名包" class="headerlink" title="导入匿名包"></a>导入匿名包</h5><blockquote>
<p>如果只希望导入包，而不使用任何包内的结构和类型，也不调用包内的任何函数时，可以使用匿名导入包</p>
</blockquote>
<p>使用下划线导入一个匿名包格式如下：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import _ "path/to/package"</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>注意：<strong>匿名包也会和其它包一样，也会被编译到可执行文件中，同时匿名包中的init函数也会被执行</strong></p>
<h3 id="io"><a href="#io" class="headerlink" title="io"></a>io</h3><p><code>ReadByte()</code>方法</p>
<blockquote>
<p><code>ReadByte()</code> 方法的功能是读取并返回一个字节。如果没有字节可读，则返回错误信息。该方法原型声明如下：</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) ReadByte() (c byte,err error)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func main()  {</span><br><span class="line">    arr:=[]byte("test")</span><br><span class="line">    rd := bytes.NewReader(arr)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    nn,err:=r.ReadByte()</span><br><span class="line">    fmt.Println(nn,err)</span><br><span class="line">    n,error_1:=r.ReadByte() //读完一个字节之后，将指针指向下一个字节</span><br><span class="line">    fmt.Println(n,error_1)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">output: </span><br><span class="line">116 &lt;nil&gt;</span><br><span class="line">101 &lt;nil&gt;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="ReadBytes-方法"><a href="#ReadBytes-方法" class="headerlink" title="ReadBytes() 方法"></a><code>ReadBytes()</code> 方法</h3><blockquote>
<p>ReadBytes() 方法的功能是 ReadBytes 读取数据直到遇到第一个分隔符“delim”，并返回读取的字节序列（包括“delim”）。如果 ReadBytes 在读到第一个“delim”之前出错，它返回已读取的数据和那个错误（通常是 io.EOF）。只有当返回的数据不以“delim”结尾时，返回的 err 才不为空值。该方法原型声明如下：</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *Reader) ReadBytes(delim byte) (line []byte, err error)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    arr:=[]byte("Hey,guy")</span><br><span class="line">    rd := bytes.NewReader(arr)</span><br><span class="line">    r := bufio.NewReader(rd)</span><br><span class="line">    n,err:=r.ReadBytes(',')</span><br><span class="line">    fmt.Println(string(n),err)</span><br><span class="line">    n,err=r.ReadBytes(',')</span><br><span class="line">    fmt.Println(string(n),err)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Hey, &lt;nil&gt;</span><br><span class="line">guy EOF</span><br></pre></td></tr></tbody></table></figure>
<h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><h4 id="接口被实现的条件一：接口的方法与实现接口的类型方法格式一致"><a href="#接口被实现的条件一：接口的方法与实现接口的类型方法格式一致" class="headerlink" title="接口被实现的条件一：接口的方法与实现接口的类型方法格式一致"></a>接口被实现的条件一：接口的方法与实现接口的类型方法格式一致</h4><blockquote>
<p>在类型中添加与接口签名一致的方法就可以实现该方法。签名包括方法中的名称、参数列表、返回参数列表。也就是说，只要实现接口类型中的方法的名称、参数列表、返回参数列表中的任意一项与接口要实现的方法不一致，那么接口的这个方法就不会被实现。</p>
</blockquote>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Print <span class="keyword">interface</span>{</span><br><span class="line">    Printdata(data <span class="keyword">interface</span>{}) error</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span>{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Data)</span> <span class="title">Printdata</span><span class="params">(data <span class="keyword">interface</span>{})</span> <span class="title">error</span></span> {</span><br><span class="line">    fmt.Println(data)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    f:=&amp;Data{}</span><br><span class="line">    <span class="keyword">var</span> toPrint Print</span><br><span class="line">    toPrint = f <span class="comment">//虽然f和toPrint变量类型不一致，但是toPrint是一个接口，而且toPrint中的方法已经被Printdata全部实现，所以是可以直接赋值</span></span><br><span class="line">    toPrint.Printdata(<span class="string">"Hello World!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果结构体中没有实现接口中的所有方法，那么就会报错。</p>
<h4 id="接口被实现的条件二：接口中所有方法均被实现"><a href="#接口被实现的条件二：接口中所有方法均被实现" class="headerlink" title="接口被实现的条件二：接口中所有方法均被实现"></a>接口被实现的条件二：接口中所有方法均被实现</h4><blockquote>
<p>当一个接口中有多个方法时，只有这些方法都被实现了，接口才能被正确编译并使用。</p>
</blockquote>
<p>如果我们在接口中新添加一个方法<code>IsPrint()</code>，如果结构体中没有实现，那么也会编译不通过</p>
<h4 id="多个类型可以实现相同的接口"><a href="#多个类型可以实现相同的接口" class="headerlink" title="多个类型可以实现相同的接口"></a>多个类型可以实现相同的接口</h4><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span>{</span><br><span class="line">    Start()</span><br><span class="line">    Logger(<span class="keyword">string</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Showlog <span class="keyword">struct</span>{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyService <span class="keyword">struct</span>{</span><br><span class="line">    Showlog</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(S *Showlog)</span> <span class="title">Logger</span><span class="params">(log <span class="keyword">string</span>)</span></span>{</span><br><span class="line">    fmt.Println(log,<span class="string">"is running"</span>)</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(M *MyService)</span> <span class="title">Start</span><span class="params">()</span></span>{</span><br><span class="line">    fmt.Println(<span class="string">"The service begin run"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">var</span> s Service = &amp;MyService{}</span><br><span class="line">    s.Start()</span><br><span class="line">    s.Logger(<span class="string">"localhost"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="goland的常见标准库"><a href="#goland的常见标准库" class="headerlink" title="goland的常见标准库"></a>goland的常见标准库</h2><h3 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h3><p><code>HasPrefix</code>判断字符串s是否以prefix开头:<br>函数签名<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.HasPrefix(s, prefix string) bool</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>HasSuffix</code>判断字符串 s 是否以 suffix 结尾：</p>
<p>函数签名<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.HasSuffix(s, suffix string) bool</span><br></pre></td></tr></tbody></table></figure><p></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main()  {</span><br><span class="line">    fmt.Println(strings.HasPrefix("this is strings","th"))</span><br><span class="line">    fmt.Println(strings.HasSuffix("this is strings","ings"))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></tbody></table></figure>
<p><code>Contains</code>字符串包含关系</p>
<blockquote>
<p>功能：字符串s中是否包含substr，返回bool值</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Contains(s, substr string) bool</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.Contains("this my world!","this"))</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">true</span><br></pre></td></tr></tbody></table></figure>
<p><code>Join</code>(拼接slice到字符串，不能是数组)</p>
<blockquote>
<p>Join 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串</p>
</blockquote>
<p>函数签名<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Join(sl []string, sep string) string</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>例子<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr:=[]string {"abc","def"}</span><br><span class="line">fmt.Println(strings.Join(arr,""))</span><br><span class="line">fmt.Println(strings.Join(arr,","))</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">abcdef</span><br><span class="line">abc,def</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>Index</code></p>
<blockquote>
<p>在字符串s中查找sep所在的位置，返回位置值，找不到返回-1</p>
</blockquote>
<p>语法：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Index(s, str string) int</span><br></pre></td></tr></tbody></table></figure><p></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.Index("this is my world","is"))</span><br><span class="line"></span><br><span class="line">output: 2</span><br></pre></td></tr></tbody></table></figure>
<p>LastIndex</p>
<blockquote>
<p>LastIndex 返回字符串 str 在字符串 s 中最后出现位置的索引（str 的第一个字符的索引），-1 表示字符串 s 不包含字符串 str：</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.LastIndex(s, str string) int</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.LastIndex("this is my world","is"))</span><br><span class="line"></span><br><span class="line">output: 5</span><br></pre></td></tr></tbody></table></figure>
<p>如果需要查询非 ASCII 编码的字符在父字符串中的位置，建议使用以下函数来对字符进行定位：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.IndexRune(s string, r rune) int</span><br></pre></td></tr></tbody></table></figure><p></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str:="this is my world"</span><br><span class="line">fmt.Println(strings.IndexRune(str,rune('a')))</span><br><span class="line">fmt.Println(strings.IndexRune(str,111))</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">-1</span><br><span class="line">12</span><br></pre></td></tr></tbody></table></figure>
<p>Count</p>
<blockquote>
<p>Count 用于计算字符串 str 在字符串 s 中出现的非重叠次数：</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Count(s, str string) int</span><br></pre></td></tr></tbody></table></figure>
<p>例子<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str:="this is my world"</span><br><span class="line">fmt.Println(strings.Count(str,"is"))</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Repeat</p>
<blockquote>
<p>重复s字符串count次，并返回一个新的字符串</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Repeat(s string, count int) string</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str:="this is my world"</span><br><span class="line">fmt.Println(strings.Repeat(str,3))</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">this is my worldthis is my worldthis is my world</span><br></pre></td></tr></tbody></table></figure>
<p>Replace (字符串替换)</p>
<blockquote>
<p>在s字符串中，把old字符串替换为new字符串，n表示替换的次数，小于0表示全部替换</p>
</blockquote>
<p>注意：替换的次数必须有，不然就会报错<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Replace(s, old, new string, n int) string</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>例子<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str:="this is my world"</span><br><span class="line">fmt.Println(strings.Replace(str,"is","are",2))</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p>时间戳<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">now:=time.Now()</span><br><span class="line">fmt.Println(now.Unix())</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>延时<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time.Sleep(3 *time.Second) //延时3秒</span><br><span class="line">time.Sleep(3 *time.Minute) //延时3分钟</span><br><span class="line">time.Sleep(3 *time.Hour) //延时3小时</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h3><p>Printf</p>
<p><em>整数型</em><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%b    表示为二进制</span><br><span class="line">%c    该值对应的unicode码值</span><br><span class="line">%d    表示为十进制</span><br><span class="line">%o    表示为八进制</span><br><span class="line">%q    该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示</span><br><span class="line">%x    表示为十六进制，使用a-f</span><br><span class="line">%X    表示为十六进制，使用A-F</span><br><span class="line">%U    表示为Unicode格式：U+1234，等价于"U+%04X"</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="math-big"><a href="#math-big" class="headerlink" title="math/big"></a>math/big</h3><blockquote>
<p>主要用于大数运算</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//设置一个大于Int64的10进制整数</span><br><span class="line">bigint := new(big.Int)</span><br><span class="line">mybigint, _ := bigint.SetString("115792089237316195423570985008687907853269984665640564039457584007913129639936", 10)</span><br><span class="line"></span><br><span class="line">//输出可以用%v或者用String()方法</span><br><span class="line">fmt.Printf("%v\n",a)</span><br><span class="line">fmt.Println(a.String())</span><br><span class="line"></span><br><span class="line">//大数相加</span><br><span class="line"></span><br><span class="line">c:=big.NewInt(1)</span><br><span class="line">mybigint.Add(mybigint,c) //Add的返回值是一个big.Int对象，即mybigint+c的结果</span><br><span class="line">fmt.Println(mybigint.String())</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bigint := new(big.Int)</span><br><span class="line">mybigint, _ := bigint.SetString("115792089237316195423570985008687907853269984665640564039457584007913129639936", 10)</span><br><span class="line">c:=big.NewInt(1)</span><br><span class="line">f:=big.NewInt(1)</span><br><span class="line">d:=f.Add(mybigint,c)</span><br><span class="line">fmt.Println(mybigint.String()) //此时mybigint的值没有发生变化</span><br><span class="line">fmt.Println(f.String())         //此时f的值发生了变化</span><br><span class="line">fmt.Println(d.String())         //此时d的值发生了变化</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">115792089237316195423570985008687907853269984665640564039457584007913129639936</span><br><span class="line">115792089237316195423570985008687907853269984665640564039457584007913129639937</span><br><span class="line">115792089237316195423570985008687907853269984665640564039457584007913129639937</span><br></pre></td></tr></tbody></table></figure>
<h3 id="os包"><a href="#os包" class="headerlink" title="os包"></a>os包</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(os.Getegid()) //</span><br><span class="line">fmt.Println(os.Chdir("../")) //改变工作目录</span><br><span class="line">fmt.Println(os.Getwd()) //获取当前工作目录</span><br><span class="line">fmt.Println(os.Getenv("tmp")) //返回指定环境变量</span><br><span class="line">fmt.Println(os.Environ()) //返回所有环境变量</span><br><span class="line">//os.Exit(0) //系统退出，并返回 code，其中 0 表示执行成功并退出，非 0 表示错误并退出</span><br><span class="line">fmt.Println(os.Getpid()) //获取进程id</span><br><span class="line">fmt.Println(os.Getppid()) //获取父进程id</span><br><span class="line">fmt.Println(os.Hostname()) //获取主机名</span><br></pre></td></tr></tbody></table></figure>
<h3 id="os-exec"><a href="#os-exec" class="headerlink" title="os/exec"></a>os/exec</h3><p>执行系统命令<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">	c:=exec.Command("ipconfig")</span><br><span class="line">	cmd,err:=c.CombinedOutput()</span><br><span class="line">	if err!=nil {</span><br><span class="line">		fmt.Printf("%v",err)</span><br><span class="line">	}else{</span><br><span class="line">		fmt.Printf("%s",string(cmd))</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">	"log"</span><br><span class="line">)</span><br><span class="line">func main() {</span><br><span class="line">	log.Println("Gooood")</span><br><span class="line">	log.Println("Loooog")</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">2019/12/03 23:05:40 Gooood</span><br><span class="line">2019/12/03 23:05:40 Loooog</span><br></pre></td></tr></tbody></table></figure>
<p>自定义Logger类型，log.Logger提供了一个New方法用来创建对象：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func New(out io.Writer, prefix string, flag int) *Logger</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>该函数一共有三个参数：</p>
<ol>
<li>输出位置out，是一个io.Writer对象，该对象可以是一个文件也可以是实现了该接口的对象。通常我们可以用这个来指定日志输出到哪个文件。</li>
<li>prefix 我们在前面已经看到，就是在日志内容前面的东西。我们可以将其置为 “[Info]” 、 “[Warning]”等来帮助区分日志级别。</li>
<li>flags 是一个选项，显示日志开头的东西，可选的值有：<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ldate         = 1 &lt;&lt; iota     // 形如 2009/01/23 的日期</span><br><span class="line">Ltime                         // 形如 01:23:23   的时间</span><br><span class="line">Lmicroseconds                 // 形如 01:23:23.123123   的时间</span><br><span class="line">Llongfile                     // 全路径文件名和行号: /a/b/c/d.go:23 </span><br><span class="line">Lshortfile                    // 文件名和行号: d.go:23</span><br><span class="line">LstdFlags     = Ldate | Ltime // 日期和时间</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<p>设置前缀、输出格式<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="comment">// var out io.Writer</span></span><br><span class="line">	debugger:=log.New(os.Stdout,<span class="string">"[info]\t"</span>,log.Llongfile)</span><br><span class="line">	debugger.Println(<span class="string">"Gooood"</span>)</span><br><span class="line">	debugger.Println(<span class="string">"Loooog"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="regexp"><a href="#regexp" class="headerlink" title="regexp"></a>regexp</h3><p>Golang的正则提供16种正则匹配方法<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Find(All)?(String)?(Submatch)?(Index)?</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>MustCompile</code>和<code>Compile</code>区别<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MustCompile 的作用和 Compile 一样</span><br><span class="line">不同的是，当正则表达式 str 不合法时，MustCompile 会抛出异常</span><br><span class="line">而 Compile 仅返回一个 error 值</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>CompilePOSIX和 Compile的区别<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompilePOSIX 的作用和 Compile 一样</span><br><span class="line">不同的是，CompilePOSIX 使用 POSIX 语法，</span><br><span class="line">同时，它采用最左最长方式搜索，</span><br><span class="line">而 Compile 采用最左最短方式搜索</span><br><span class="line">POSIX 语法不支持 Perl 的语法格式：\d、\D、\s、\S、\w、\W</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>Match</code></p>
<blockquote>
<p><code>func Match(pattern string, b []byte) (matched bool, err error)</code>，</p>
</blockquote>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search := <span class="string">"baidu:https://www.baidu.com google:https://www.google.com"</span></span><br><span class="line">pattern := <span class="string">`(http|https)?://[a-zA-Z0-9\.]+\.(com|net|cn|gov|edu)+`</span></span><br><span class="line">re := regexp.MustCompile(pattern)</span><br><span class="line">fmt.Println(re.Match([]<span class="keyword">byte</span>(search)))</span><br></pre></td></tr></tbody></table></figure>
<p><code>MatchReader</code></p>
<blockquote>
<p><code>func MatchReader(pattern string, r io.RuneReader) (matched bool, err error)</code>，r：要在其中进行查找的 RuneReader 接口</p>
</blockquote>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search := bytes.NewReader([]<span class="keyword">byte</span>(<span class="string">"baidu:https://www.baidu.com google:https://www.google.com"</span>))</span><br><span class="line">pattern := <span class="string">`(http|https)?://[a-zA-Z0-9\.]+\.(com|net|cn|gov|edu)+`</span></span><br><span class="line">re := regexp.MustCompile(pattern)</span><br><span class="line">fmt.Println(re.MatchReader(search))</span><br></pre></td></tr></tbody></table></figure>
<p><code>MatchString</code></p>
<blockquote>
<p>返回是否匹配到结果，true或者false</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search := "baidu:https://www.baidu.com google:https://www.google.com"</span><br><span class="line">pattern := `(http|https)?://[a-zA-Z0-9\.]+\.(com|net|cn|gov|edu)+`</span><br><span class="line">re := regexp.MustCompile(pattern)</span><br><span class="line">ok:=re.MatchString(search)</span><br><span class="line">fmt.Println(ok)</span><br></pre></td></tr></tbody></table></figure>
<p><code>Find</code></p>
<blockquote>
<p><code>func (re *Regexp) Find(b []byte) []byte</code>，查找byte数组，并返回第一个匹配的内容</p>
</blockquote>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search := <span class="string">"baidu:https://www.baidu.com google:https://www.google.com"</span></span><br><span class="line">pattern := <span class="string">`(http|https)?://[a-zA-Z0-9\.]+\.(com|net|cn|gov|edu)+`</span></span><br><span class="line">re := regexp.MustCompile(pattern)</span><br><span class="line">match:=re.Find([]<span class="keyword">byte</span>(search))</span><br><span class="line">fmt.Println(match)</span><br></pre></td></tr></tbody></table></figure>
<p><code>FindAll</code></p>
<blockquote>
<p><code>func (re *Regexp) FindAll(b []byte, n int) [][]byte</code>，查找前n个匹配项，如果n&lt;0，则查找所有匹配项</p>
</blockquote>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search := <span class="string">"baidu:https://www.baidu.com google:https://www.google.com"</span></span><br><span class="line">pattern := <span class="string">`(http|https)?://[a-zA-Z0-9\.]+\.(com|net|cn|gov|edu)+`</span></span><br><span class="line">re := regexp.MustCompile(pattern)</span><br><span class="line">match:=re.FindAll([]<span class="keyword">byte</span>(search),<span class="number">-1</span>)</span><br><span class="line">fmt.Println(match)</span><br></pre></td></tr></tbody></table></figure>
<p><code>FindString</code></p>
<blockquote>
<p><code>func (re *Regexp) FindString(s string) string</code>，查找字符串，并返回第一个找到的结果</p>
</blockquote>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search := <span class="string">"baidu:https://www.baidu.com google:https://www.google.com"</span></span><br><span class="line">pattern := <span class="string">`(http|https)?://[a-zA-Z0-9\.]+\.(com|net|cn|gov|edu)+`</span></span><br><span class="line">re := regexp.MustCompile(pattern)</span><br><span class="line">match:=re.FindString(search)</span><br><span class="line">fmt.Println(match)</span><br></pre></td></tr></tbody></table></figure>
<p><code>FindAllString</code></p>
<blockquote>
<p><code>func (re *Regexp) FindAllString(s string, n int) []string</code>，查找前n个匹配项，如果n&lt;0，则查找所有匹配项</p>
</blockquote>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	search := <span class="string">"baidu:https://www.baidu.com google:https://www.google.com"</span></span><br><span class="line">	pattern := <span class="string">`(http|https)?://[a-zA-Z0-9\.]+\.(com|net|cn|gov|edu)+`</span></span><br><span class="line">	re := regexp.MustCompile(pattern) <span class="comment">//只有如果返回值，如果放回nil则说明没有匹配的结果</span></span><br><span class="line">	fmt.Println(re.FindAllString(search, <span class="number">-1</span>)) </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>FindAllStringIndex</code></p>
<blockquote>
<p><code>func (re *Regexp) FindAllStringIndex(s string, n int) [][]int</code>，返回匹配到的字符串的位置，[[起始位置, 结束位置], [起始位置, 结束位置], …]</p>
</blockquote>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search := <span class="string">"baidu:https://www.baidu.com google:https://www.google.com"</span></span><br><span class="line">pattern := <span class="string">`(http|https)?://[a-zA-Z0-9\.]+\.(com|net|cn|gov|edu)+`</span></span><br><span class="line">re := regexp.MustCompile(pattern)</span><br><span class="line">fmt.Println(re.FindAllStringIndex(search,<span class="number">-1</span>))</span><br></pre></td></tr></tbody></table></figure>
<p><code>FindStringSubmatch</code></p>
<blockquote>
<p><code>func (re *Regexp) FindStringSubmatch(s string) []string</code>，匹配子组的内容，第一个返回的内容是匹配到的整一个字符串。{完整匹配项, 子匹配项, 子匹配项, …}</p>
</blockquote>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search := <span class="string">"baidu:https://www.baidu.com google:https://www.google.com"</span></span><br><span class="line">pattern := <span class="string">`(http|https)?://[a-zA-Z0-9\.]+\.(com|net|cn|gov|edu)+`</span></span><br><span class="line">re := regexp.MustCompile(pattern)</span><br><span class="line">fmt.Println(re.FindStringSubmatch(search))</span><br></pre></td></tr></tbody></table></figure>
<p><code>ReplaceAllString</code></p>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">search := <span class="string">"baidu:https://www.baidu.com google:https://www.google.com"</span></span><br><span class="line">pattern := <span class="string">`(http|https)?://[a-zA-Z0-9\.]+\.(com|net|cn|gov|edu)+`</span></span><br><span class="line">re := regexp.MustCompile(pattern)</span><br><span class="line">fmt.Println(re.ReplaceAllString(search,<span class="string">"${1}http://www.test.com"</span>))</span><br><span class="line"></span><br><span class="line">baidu:http:<span class="comment">//www.test.com google:http://www.test.com</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>ReplaceAllLiteralString</code></p>
<blockquote>
<p><code>func (re *Regexp) ReplaceAllLiteralString(src, repl string) string</code>， 如果 repl 中有”分组引用符”（$1、$name），则将“分组引用符”当普通字符处理</p>
</blockquote>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">search := <span class="string">"baidu:https://www.baidu.com google:https://www.google.com"</span></span><br><span class="line">pattern := <span class="string">`(http|https)?://[a-zA-Z0-9\.]+\.(com|net|cn|gov|edu)+`</span></span><br><span class="line">re := regexp.MustCompile(pattern)</span><br><span class="line">fmt.Println(re.ReplaceAllLiteralString(search,<span class="string">"${1}http://www.test.com"</span>))</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">baidu:${<span class="number">1</span>}http:<span class="comment">//www.test.com google:${1}http://www.test.com</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>Split</code></p>
<blockquote>
<p><code>func (re *Regexp) Split(s string, n int) []string</code> 最多分割出 n 个子串，第 n 个子串不再进行分割 如果 n &lt; 0，则分割所有子串 返回分割后的子串列表</p>
</blockquote>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">search := <span class="string">"baidu:https://www.baidu.com google:https://www.google.com"</span></span><br><span class="line">pattern := <span class="string">`(http|https)?://[a-zA-Z0-9\.]+\.(com|net|cn|gov|edu)+`</span></span><br><span class="line">re := regexp.MustCompile(pattern)</span><br><span class="line">fmt.Println(re.Split(search,<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[baidu:  google: ]</span><br></pre></td></tr></tbody></table></figure>
<p><code>String</code></p>
<blockquote>
<p>返回 re 中的“正则表达式”字符串</p>
</blockquote>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern := <span class="string">`(http|https)?://[a-zA-Z0-9\.]+\.(com|net|cn|gov|edu)+`</span></span><br><span class="line">re := regexp.MustCompile(pattern)</span><br><span class="line">fmt.Println(re.String())</span><br></pre></td></tr></tbody></table></figure>
<h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><h4 id="encoding-hex"><a href="#encoding-hex" class="headerlink" title="encoding/hex"></a>encoding/hex</h4><blockquote>
<p>hex</p>
</blockquote>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">name:=[]<span class="keyword">byte</span>(<span class="string">"test"</span>)</span><br><span class="line"><span class="comment">//字符串转化为16进制</span></span><br><span class="line">fmt.Println(hex.EncodeToString(name)) </span><br><span class="line"><span class="comment">//字符串转化为16进制</span></span><br><span class="line">endst:=<span class="built_in">make</span>([]<span class="keyword">byte</span>,hex.EncodedLen(<span class="built_in">len</span>(name)))</span><br><span class="line">hex.Encode(endst,[]<span class="keyword">byte</span>(name))</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(endst))</span><br><span class="line"><span class="comment">//16转字符串</span></span><br><span class="line">dst:=<span class="built_in">make</span>([]<span class="keyword">byte</span>,hex.DecodedLen(<span class="built_in">len</span>((<span class="string">"74657374"</span>))))</span><br><span class="line">hex.Decode(dst,[]<span class="keyword">byte</span>(<span class="string">"74657374"</span>))</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(dst))</span><br><span class="line"><span class="comment">//16转字符串</span></span><br><span class="line">hex2str,_:=hex.DecodeString(<span class="string">"74657374"</span>)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(hex2str))</span><br><span class="line"><span class="comment">//hexdump</span></span><br><span class="line">hexdump:=[]<span class="keyword">byte</span>(<span class="string">"A strong man will struggle with the storms of fate. -- Thomas Addison"</span>)</span><br><span class="line">fmt.Println(hex.Dump(hexdump))</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">74657374</span></span><br><span class="line"><span class="number">74657374</span></span><br><span class="line">test</span><br><span class="line">test</span><br><span class="line"><span class="number">00000000</span>  <span class="number">41</span> <span class="number">20</span> <span class="number">73</span> <span class="number">74</span> <span class="number">72</span> <span class="number">6</span>f <span class="number">6</span>e <span class="number">67</span>  <span class="number">20</span> <span class="number">6</span>d <span class="number">61</span> <span class="number">6</span>e <span class="number">20</span> <span class="number">77</span> <span class="number">69</span> <span class="number">6</span>c  |A strong man wil|</span><br><span class="line"><span class="number">00000010</span>  <span class="number">6</span>c <span class="number">20</span> <span class="number">73</span> <span class="number">74</span> <span class="number">72</span> <span class="number">75</span> <span class="number">67</span> <span class="number">67</span>  <span class="number">6</span>c <span class="number">65</span> <span class="number">20</span> <span class="number">77</span> <span class="number">69</span> <span class="number">74</span> <span class="number">68</span> <span class="number">20</span>  |l struggle with |</span><br><span class="line"><span class="number">00000020</span>  <span class="number">74</span> <span class="number">68</span> <span class="number">65</span> <span class="number">20</span> <span class="number">73</span> <span class="number">74</span> <span class="number">6</span>f <span class="number">72</span>  <span class="number">6</span>d <span class="number">73</span> <span class="number">20</span> <span class="number">6</span>f <span class="number">66</span> <span class="number">20</span> <span class="number">66</span> <span class="number">61</span>  |the storms of fa|</span><br><span class="line"><span class="number">00000030</span>  <span class="number">74</span> <span class="number">65</span> <span class="number">2</span>e <span class="number">20</span> <span class="number">2</span>d <span class="number">2</span>d <span class="number">20</span> <span class="number">54</span>  <span class="number">68</span> <span class="number">6</span>f <span class="number">6</span>d <span class="number">61</span> <span class="number">73</span> <span class="number">20</span> <span class="number">41</span> <span class="number">64</span>  |te. -- Thomas Ad|</span><br><span class="line"><span class="number">00000040</span>  <span class="number">64</span> <span class="number">69</span> <span class="number">73</span> <span class="number">6</span>f <span class="number">6</span>e                                    |dison|</span><br></pre></td></tr></tbody></table></figure>
<h4 id="encoding-base64"><a href="#encoding-base64" class="headerlink" title="encoding/base64"></a>encoding/base64</h4><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//base64编码</span></span><br><span class="line">b64:=[]<span class="keyword">byte</span>(<span class="string">"test"</span>)</span><br><span class="line">str2b64:=base64.StdEncoding.EncodeToString(b64)</span><br><span class="line">fmt.Println(str2b64)</span><br><span class="line"><span class="comment">//base64编码</span></span><br><span class="line">dst:=<span class="built_in">make</span>([]<span class="keyword">byte</span>,base64.StdEncoding.EncodedLen(<span class="built_in">len</span>(b64)))</span><br><span class="line">base64.StdEncoding.Encode(dst,b64)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(dst))</span><br><span class="line"><span class="comment">//base64解码</span></span><br><span class="line">data:=<span class="string">"dGVzdA=="</span></span><br><span class="line">b642str,_:=base64.StdEncoding.DecodeString(data)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(b642str))</span><br><span class="line"><span class="comment">//base64解码</span></span><br><span class="line">data_1:=[]<span class="keyword">byte</span>(data)</span><br><span class="line">dst=<span class="built_in">make</span>([]<span class="keyword">byte</span>,base64.StdEncoding.DecodedLen(<span class="built_in">len</span>(data_1)))</span><br><span class="line">base64.StdEncoding.Decode(dst,data_1)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(dst))</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">dGVzdA==</span><br><span class="line">dGVzdA==</span><br><span class="line">test</span><br><span class="line">test</span><br></pre></td></tr></tbody></table></figure>
<h3 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h3><h4 id="crypto-md5"><a href="#crypto-md5" class="headerlink" title="crypto/md5"></a>crypto/md5</h4><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MD5</span></span><br><span class="line">data := []<span class="keyword">byte</span>(<span class="string">"test"</span>)</span><br><span class="line">mymd5:=fmt.Sprintf(<span class="string">"%x"</span>,md5.Sum(data)) <span class="comment">//注意md5.Sum(data)返回是一个数组而不是切片</span></span><br><span class="line">fmt.Println(mymd5)</span><br><span class="line"></span><br><span class="line"><span class="comment">//sha1</span></span><br><span class="line">data := []<span class="keyword">byte</span>(<span class="string">"test"</span>)</span><br><span class="line">mymd5:=fmt.Sprintf(<span class="string">"%x"</span>,sha1.Sum(data))</span><br><span class="line">fmt.Println(mymd5)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="crypto-sha256"><a href="#crypto-sha256" class="headerlink" title="crypto/sha256"></a>crypto/sha256</h4><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data := []<span class="keyword">byte</span>(<span class="string">"test"</span>)</span><br><span class="line">mysha224:=fmt.Sprintf(<span class="string">"%x"</span>,sha256.Sum224(data)) <span class="comment">//sha224</span></span><br><span class="line">mysha256:=fmt.Sprintf(<span class="string">"%x"</span>,sha256.Sum256(data)) <span class="comment">//sha256</span></span><br><span class="line">fmt.Println(mysha224)</span><br><span class="line">fmt.Println(mysha256)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="crypto-sha512"><a href="#crypto-sha512" class="headerlink" title="crypto/sha512"></a>crypto/sha512</h4><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data := []<span class="keyword">byte</span>(<span class="string">"test"</span>)</span><br><span class="line">mysha384:=fmt.Sprintf(<span class="string">"%x"</span>,sha512.Sum384(data)) <span class="comment">//sha384</span></span><br><span class="line">mysha512:=fmt.Sprintf(<span class="string">"%x"</span>,sha512.Sum512(data)) <span class="comment">//sha512</span></span><br><span class="line">fmt.Println(mysha384)</span><br><span class="line">fmt.Println(mysha512)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="crypto-rand"><a href="#crypto-rand" class="headerlink" title="crypto/rand"></a>crypto/rand</h4><p><code>rand.Reader</code></p>
<blockquote>
<p>ReadFull从rand.Reader精确地读取len(b)字节数据填充进b，rand.Reader是一个全局、共享的密码用强随机数生成器</p>
</blockquote>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b:=<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">64</span>)</span><br><span class="line">io.ReadFull(rand.Reader,b)</span><br><span class="line">fmt.Println(b)</span><br><span class="line">output:</span><br><span class="line">[<span class="number">132</span> <span class="number">20</span> <span class="number">249</span> <span class="number">35</span> <span class="number">161</span> <span class="number">31</span> <span class="number">131</span> <span class="number">62</span> <span class="number">200</span> <span class="number">97</span> <span class="number">167</span> <span class="number">216</span> <span class="number">145</span> <span class="number">88</span> <span class="number">146</span> <span class="number">242</span> <span class="number">249</span> <span class="number">70</span> <span class="number">7</span> <span class="number">62</span> <span class="number">249</span> <span class="number">47</span> <span class="number">240</span> <span class="number">60</span> <span class="number">73</span> <span class="number">89</span> <span class="number">148</span> <span class="number">232</span> <span class="number">61</span> <span class="number">187</span> <span class="number">77</span> <span class="number">241</span> <span class="number">179</span> <span class="number">12</span> <span class="number">24</span> <span class="number">84</span> <span class="number">118</span> <span class="number">164</span> <span class="number">101</span> <span class="number">244</span> <span class="number">240</span> <span class="number">4</span> <span class="number">55</span> <span class="number">11</span> <span class="number">59</span> <span class="number">255</span> <span class="number">140</span> <span class="number">206</span> <span class="number">10</span> <span class="number">81</span> <span class="number">170</span> <span class="number">107</span> <span class="number">57</span> <span class="number">195</span> <span class="number">27</span> <span class="number">122</span> <span class="number">3</span> <span class="number">81</span> <span class="number">207</span> <span class="number">123</span> <span class="number">53</span> <span class="number">14</span> <span class="number">241</span> <span class="number">91</span>]</span><br></pre></td></tr></tbody></table></figure>
<p><code>Prime</code></p>
<blockquote>
<p><code>Prime(rand io.Reader, bits int) (p *big.Int, err error)</code>，生成一个n bit的素数，如果n&lt;2，则会返回一个error</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p,_:=rand.Prime(rand.Reader,2048) //生成一个2048bit的素数</span><br><span class="line">fmt.Printf("%T\n",p)</span><br><span class="line">fmt.Println(p)</span><br></pre></td></tr></tbody></table></figure>
<p><code>rand.Int</code></p>
<blockquote>
<p><code>Int(rand io.Reader, max *big.Int) (n *big.Int, err error)</code>，取一个[0,max)的整数</p>
</blockquote>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max:=big.NewInt(math.MaxInt64)</span><br><span class="line">r,_:=rand.Int(rand.Reader,max)</span><br><span class="line">fmt.Println(r)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="crypto-aes"><a href="#crypto-aes" class="headerlink" title="crypto/aes"></a>crypto/aes</h4><p>golang实现aes加密解密<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bytes"</span></span><br><span class="line">	<span class="string">"crypto/aes"</span></span><br><span class="line">	<span class="string">"crypto/cipher"</span></span><br><span class="line">	<span class="string">"crypto/rand"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">padding</span><span class="params">(data []<span class="keyword">byte</span>, BlackSize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> {</span><br><span class="line">	PadLen := BlackSize - <span class="built_in">len</span>(data)%BlackSize</span><br><span class="line">	PadData := bytes.Repeat([]<span class="keyword">byte</span>{<span class="keyword">byte</span>(PadLen)}, PadLen)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">append</span>(data, PadData...)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpadding</span><span class="params">(data []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> {</span><br><span class="line">	n := <span class="built_in">len</span>(data)</span><br><span class="line">	UnpadLen := <span class="keyword">int</span>(data[n<span class="number">-1</span>])</span><br><span class="line">	UnpadData := data[:n-UnpadLen]</span><br><span class="line">	<span class="keyword">return</span> UnpadData</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecryptoAES</span><span class="params">(data []<span class="keyword">byte</span>, key []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> {</span><br><span class="line">	block, err := aes.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	}</span><br><span class="line">	Decrypter := cipher.NewCBCDecrypter(block, key)</span><br><span class="line">	<span class="comment">// var DecryptData []byte</span></span><br><span class="line">	DecryptData := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(data))</span><br><span class="line">	Decrypter.CryptBlocks(DecryptData, data)</span><br><span class="line">	DecryptData = unpadding(DecryptData)</span><br><span class="line">	<span class="keyword">return</span> DecryptData, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncryptoAES</span><span class="params">(data []<span class="keyword">byte</span>, key []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> {</span><br><span class="line">	block, err := aes.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	}</span><br><span class="line">	paddata := padding(data, block.BlockSize())</span><br><span class="line">	Encrypter := cipher.NewCBCEncrypter(block, key)</span><br><span class="line">	EncryptData := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(paddata))</span><br><span class="line">	Encrypter.CryptBlocks(EncryptData, paddata)</span><br><span class="line">	<span class="keyword">return</span> EncryptData, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	data := []<span class="keyword">byte</span>(<span class="string">"Why not go far without dreams"</span>)</span><br><span class="line">	key := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">16</span>)</span><br><span class="line">	io.ReadFull(rand.Reader, key)</span><br><span class="line">	fmt.Println(key)</span><br><span class="line">	endata, _ := EncryptoAES(data, key)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(endata))</span><br><span class="line">	dedata, _ := DecryptoAES(endata, key)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(dedata))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h4 id="crypto-des"><a href="#crypto-des" class="headerlink" title="crypto/des"></a>crypto/des</h4><p><code>crypto/des</code>包中实现了des加密和三重des加密<br>des加密</p>
<blockquote>
<p>和aes差不多，就改一下方法就行了</p>
</blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"bytes"</span><br><span class="line">	"crypto/des"</span><br><span class="line">	"crypto/cipher"</span><br><span class="line">	"crypto/rand"</span><br><span class="line">	"fmt"</span><br><span class="line">	"io"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func padding(data []byte, BlackSize int) []byte {</span><br><span class="line">	PadLen := BlackSize - len(data)%BlackSize</span><br><span class="line">	PadData := bytes.Repeat([]byte{byte(PadLen)}, PadLen)</span><br><span class="line">	return append(data, PadData...)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func unpadding(data []byte) []byte {</span><br><span class="line">	n := len(data)</span><br><span class="line">	UnpadLen := int(data[n-1])</span><br><span class="line">	UnpadData := data[:n-UnpadLen]</span><br><span class="line">	return UnpadData</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func DecryptoDES(data []byte, key []byte) ([]byte, error) {</span><br><span class="line">	block, err := des.NewCipher(key)</span><br><span class="line">	if err != nil {</span><br><span class="line">		return nil, err</span><br><span class="line">	}</span><br><span class="line">	Decrypter := cipher.NewCBCDecrypter(block, key)</span><br><span class="line">	DecryptData := make([]byte, len(data))</span><br><span class="line">	Decrypter.CryptBlocks(DecryptData, data)</span><br><span class="line">	DecryptData = unpadding(DecryptData)</span><br><span class="line">	return DecryptData, nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func EncryptoDES(data []byte, key []byte) ([]byte, error) {</span><br><span class="line">	block, err := des.NewCipher(key)</span><br><span class="line">	if err != nil {</span><br><span class="line">		return nil, err</span><br><span class="line">	}</span><br><span class="line">	paddata := padding(data, block.BlockSize())</span><br><span class="line">	Encrypter := cipher.NewCBCEncrypter(block, key)</span><br><span class="line">	EncryptData := make([]byte, len(paddata))</span><br><span class="line">	Encrypter.CryptBlocks(EncryptData, paddata)</span><br><span class="line">	return EncryptData, nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">	data := []byte("Why not go far without dreams")</span><br><span class="line">	key := make([]byte, 8) // key的长度必须为8</span><br><span class="line">	io.ReadFull(rand.Reader, key)</span><br><span class="line">	fmt.Println(key)</span><br><span class="line">	endata, _ := EncryptoDES(data, key)</span><br><span class="line">	fmt.Println(string(endata))</span><br><span class="line">	dedata, _ := DecryptoDES(endata, key)</span><br><span class="line">	fmt.Println(string(dedata))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>3des<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bytes"</span></span><br><span class="line">	<span class="string">"crypto/des"</span></span><br><span class="line">	<span class="string">"crypto/cipher"</span></span><br><span class="line">	<span class="string">"crypto/rand"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">padding</span><span class="params">(data []<span class="keyword">byte</span>, BlackSize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> {</span><br><span class="line">	PadLen := BlackSize - <span class="built_in">len</span>(data)%BlackSize</span><br><span class="line">	PadData := bytes.Repeat([]<span class="keyword">byte</span>{<span class="keyword">byte</span>(PadLen)}, PadLen)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">append</span>(data, PadData...)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unpadding</span><span class="params">(data []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> {</span><br><span class="line">	n := <span class="built_in">len</span>(data)</span><br><span class="line">	UnpadLen := <span class="keyword">int</span>(data[n<span class="number">-1</span>])</span><br><span class="line">	UnpadData := data[:n-UnpadLen]</span><br><span class="line">	<span class="keyword">return</span> UnpadData</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecryptoTripleDES</span><span class="params">(data []<span class="keyword">byte</span>, key []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> {</span><br><span class="line">	block, err := des.NewTripleDESCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	}</span><br><span class="line">	Decrypter := cipher.NewCBCDecrypter(block, key[:<span class="number">8</span>])</span><br><span class="line">	DecryptData := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(data))</span><br><span class="line">	Decrypter.CryptBlocks(DecryptData, data)</span><br><span class="line">	DecryptData = unpadding(DecryptData)</span><br><span class="line">	<span class="keyword">return</span> DecryptData, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncryptoTripleDES</span><span class="params">(data []<span class="keyword">byte</span>, key []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> {</span><br><span class="line">	block, err := des.NewTripleDESCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	}</span><br><span class="line">	paddata := padding(data, block.BlockSize())</span><br><span class="line">	Encrypter := cipher.NewCBCEncrypter(block, key[:<span class="number">8</span>]) <span class="comment">//vi的值必须为8，不然就会panic</span></span><br><span class="line">	EncryptData := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(paddata))</span><br><span class="line">	Encrypter.CryptBlocks(EncryptData, paddata)</span><br><span class="line">	<span class="keyword">return</span> EncryptData, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	data := []<span class="keyword">byte</span>(<span class="string">"Why not go far without dreams"</span>)</span><br><span class="line">	key := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">24</span>) <span class="comment">// key的长度必须为24</span></span><br><span class="line">	io.ReadFull(rand.Reader, key)</span><br><span class="line">	fmt.Println(key)</span><br><span class="line">	endata, _ := EncryptoTripleDES(data, key)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(endata))</span><br><span class="line">	dedata, _ := DecryptoTripleDES(endata, key)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(dedata))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h4 id="crypto-hmac"><a href="#crypto-hmac" class="headerlink" title="crypto/hmac"></a>crypto/hmac</h4><blockquote>
<p>HMAC是使用密钥对消息进行签名的加密散列</p>
</blockquote>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用hmac对hash值进行签名</span></span><br><span class="line">key:=[]<span class="keyword">byte</span>(<span class="string">"salted"</span>)</span><br><span class="line">message:=[]<span class="keyword">byte</span>(<span class="string">"Why not go far without dreams"</span>)</span><br><span class="line">enhash:=hmac.New(md5.New,key)</span><br><span class="line">enhash.Write(message)</span><br><span class="line">fmt.Printf(<span class="string">"%x\n"</span>,enhash.Sum(<span class="literal">nil</span>))</span><br><span class="line"><span class="comment">//校验</span></span><br><span class="line">hash:=[]<span class="keyword">byte</span> {<span class="number">28</span> ,<span class="number">171</span> ,<span class="number">78</span> ,<span class="number">222</span> ,<span class="number">246</span> ,<span class="number">68</span> ,<span class="number">186</span> ,<span class="number">131</span> ,<span class="number">28</span> ,<span class="number">11</span> ,<span class="number">246</span> ,<span class="number">196</span> ,<span class="number">249</span> ,<span class="number">129</span> ,<span class="number">172</span> ,<span class="number">228</span>}</span><br><span class="line">fmt.Println(hmac.Equal(enhash.Sum(<span class="literal">nil</span>),hash))</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">1</span>cab4edef644ba831c0bf6c4f981ace4</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><h4 id="hash-crc32"><a href="#hash-crc32" class="headerlink" title="hash/crc32"></a>hash/crc32</h4><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data:=crc32.ChecksumIEEE([]<span class="keyword">byte</span>(<span class="string">"crc32"</span>)) <span class="comment">//压缩包的是采用CRC-32-IEEE 802.3标准</span></span><br><span class="line">fmt.Println(data)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h3><p><strong>注意</strong>：go语言里面struct里面变量如果大写开头则是public,如果是小写开头则是private的，private的时候通过反射不能获取其值，否则会出现如下panic<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: reflect.Value.Interface: cannot return value obtained from unexported field or method</span><br></pre></td></tr></tbody></table></figure><p></p>
<h4 id="从实例到-Value"><a href="#从实例到-Value" class="headerlink" title="从实例到 Value"></a>从实例到 Value</h4><p>通过实例获取 Value 对象，直接使用 reflect.ValueOf() 函数。例如：<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span> {})</span> <span class="title">Value</span></span></span><br></pre></td></tr></tbody></table></figure><p></p>
<h4 id="从实例到-Type"><a href="#从实例到-Type" class="headerlink" title="从实例到 Type"></a>从实例到 Type</h4><p>通过实例获取反射对象的 Type，直接使用 reflect.TypeOf() 函数。例如：<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>{})</span> <span class="title">Type</span></span></span><br></pre></td></tr></tbody></table></figure><p></p>
<h4 id="从Value到实例"><a href="#从Value到实例" class="headerlink" title="从Value到实例"></a>从Value到实例</h4><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法最通用，用来将 Value 转换为空接口，该空接口内部存放具体类型实例</span></span><br><span class="line"><span class="comment">//可以使用接口类型查询去还原为具体的类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Interface</span><span class="params">()</span> （<span class="title">i</span> <span class="title">interface</span></span>{})</span><br><span class="line"></span><br><span class="line"><span class="comment">//Value 自身也提供丰富的方法，直接将 Value 转换为简单类型实例，如果类型不匹配，则会返回"&lt;" + v.Type().String() + " Value&gt;"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Bool</span> <span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Float</span><span class="params">()</span> <span class="title">float64</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Int</span><span class="params">()</span> <span class="title">int64</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(v Value)</span> <span class="title">Uint</span><span class="params">()</span> <span class="title">uint64</span></span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="从-Value-到-Type"><a href="#从-Value-到-Type" class="headerlink" title="从 Value 到 Type"></a>从 Value 到 Type</h4><p>从反射对象 Value 到 Type 可以直接调用 Type 的方法，因为 Value 内部存放着到 Type 类型的指针。例如：<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Type</span><span class="params">()</span> <span class="title">Type</span></span></span><br></pre></td></tr></tbody></table></figure><p></p>
<h4 id="从-Value-的指针到值"><a href="#从-Value-的指针到值" class="headerlink" title="从 Value 的指针到值"></a>从 Value 的指针到值</h4><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从一个指针类型的 Value 获得值类型 Value 有两种方法，示例如下。</span><br><span class="line"><span class="comment">//如果 v 类型是接口，则 Elem() 返回接口绑定的实例的 Value，如采 v 类型是指针，则返回指针值的 Value，否则引起 panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Elem</span><span class="params">()</span> <span class="title">Value</span></span></span><br><span class="line"><span class="function">//如果 <span class="title">v</span> 是指针，则返回指针值的 <span class="title">Value</span>，否则返回 <span class="title">v</span> 自身，该函数不会引起 <span class="title">panic</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Indirect</span><span class="params">(v Value)</span> <span class="title">Value</span></span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="Value-值的可修改性"><a href="#Value-值的可修改性" class="headerlink" title="Value 值的可修改性"></a>Value 值的可修改性</h4><p>Value 值的修改涉及如下两个方法：<br>//通过 CanSet 判断是否能修改<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (v Value ) CanSet() bool</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>//通过 Set 进行修改<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (v Value ) Set(x Value)</span><br></pre></td></tr></tbody></table></figure><p></p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>实例1<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="number">3.1</span></span><br><span class="line">	v := reflect.ValueOf(&amp;f)</span><br><span class="line">	fmt.Println(<span class="string">"Canset: "</span>,v.CanSet())</span><br><span class="line">	fv:=v.Elem()</span><br><span class="line">	fmt.Println(<span class="string">"Canset: "</span>,fv.CanSet())</span><br><span class="line">	fv.SetFloat(<span class="number">3.14</span>)</span><br><span class="line">	fmt.Println(f)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>实例2<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">uint16</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	zhangsan := person{<span class="string">"zhangsan"</span>, <span class="number">20</span>}</span><br><span class="line">	v := reflect.ValueOf(&amp;zhangsan).Elem()</span><br><span class="line">	t := v.Type()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ {</span><br><span class="line">		f := v.Field(i)</span><br><span class="line">		tt := t.Field(i)</span><br><span class="line">		fmt.Println(tt.Name, f.Interface(), tt.Type)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>实例3，通过反射修改结构体的值：<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">uint16</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	zhangsan := person{<span class="string">"zhangsan"</span>, <span class="number">20</span>}</span><br><span class="line">	v := reflect.ValueOf(&amp;zhangsan).Elem()</span><br><span class="line">	name:=<span class="string">"qiyou"</span></span><br><span class="line">	n:=reflect.ValueOf(name)</span><br><span class="line">	v.FieldByName(<span class="string">"Name"</span>).Set(n)</span><br><span class="line">	fmt.Println(v.Field(<span class="number">0</span>).Interface())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h4 id="Name和Kind的区别"><a href="#Name和Kind的区别" class="headerlink" title="Name和Kind的区别"></a>Name和Kind的区别</h4><p>Go 程序中的类型（Type）指的是系统原生数据类型，如 int、string、bool、float32 等类型，以及使用 type 关键字定义的类型，这些类型的名称就是其类型本身的名称（Name）。例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。</p>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myint <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> i myint</span><br><span class="line">	zhangsan:=person{}</span><br><span class="line">	t1:=reflect.TypeOf(i)</span><br><span class="line">	t2:=reflect.TypeOf(zhangsan)</span><br><span class="line">	fmt.Println(t1.Name(),t1.Kind())</span><br><span class="line">	fmt.Println(t2.Name(),t2.Kind())</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">myint <span class="keyword">int</span></span><br><span class="line">person <span class="keyword">struct</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="通过反射获取指针指向的元素类型"><a href="#通过反射获取指针指向的元素类型" class="headerlink" title="通过反射获取指针指向的元素类型"></a>通过反射获取指针指向的元素类型</h4><p>Go语言程序中对指针获取反射对象时，可以通过<code>reflect.Elem()</code> 方法获取这个指针指向的元素类型。这个获取过程被称为取元素，等效于对指针类型变量做了一个*操作</p>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	zhangsan:=person{}</span><br><span class="line">	t:=reflect.TypeOf(&amp;zhangsan)</span><br><span class="line">	fmt.Println(t.Name(),t.Kind())</span><br><span class="line">	et:=t.Elem()</span><br><span class="line">	fmt.Println(et.Name(),et.Kind())</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"> ptr <span class="comment">//Go 语言的反射中对所有指针变量的种类都是 Ptr，但注意，指针变量的类型名称是空，不是*person</span></span><br><span class="line">person <span class="keyword">struct</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="结构体标签"><a href="#结构体标签" class="headerlink" title="结构体标签"></a>结构体标签</h4><blockquote>
<p>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。</p>
</blockquote>
<p>从结构体标签中获取值<br>StructTag 拥有一些方法，可以进行 Tag 信息的解析和提取，如下所示：<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(tag StructTag)</span><span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span><span class="title">string</span></span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>根据 Tag 中的键获取对应的值，例如<code>key1:"value1"key2:"value2"</code> 的 Tag 中，可以传入“key1”获得“value1”。<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(tag StructTag)</span><span class="title">Lookup</span><span class="params">(key <span class="keyword">string</span>)</span><span class="params">(value <span class="keyword">string</span>,ok <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>根据 Tag 中的键，查询值是否存在</p>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`name:"qiyou" Sex:"man"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	zhangsan := person{}</span><br><span class="line">	t := reflect.TypeOf(zhangsan)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> name, ok := t.FieldByName(<span class="string">"Name"</span>); ok {</span><br><span class="line">		fmt.Println(name.Tag.Get(<span class="string">"name"</span>))</span><br><span class="line">		fmt.Println(name.Tag.Get(<span class="string">"Sex"</span>))</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">qiyou</span><br><span class="line">man</span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意一点就是：key和value之间不能有任何空格，即上面例子中name:”qiyou”之间不能有任何空格，如果有空格则会输出空，不会报错</strong></p>
<h4 id="通过反射获取值信息"><a href="#通过反射获取值信息" class="headerlink" title="通过反射获取值信息"></a>通过反射获取值信息</h4><p>Go语言中，使用<code>reflect.ValueOf()</code>函数获得值的反射值对象（<code>reflect.Value</code>）。书写格式如下：<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value := reflect.ValueOf(rawValue)</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>reflect.ValueOf</code> 返回<code>reflect.Value</code>类型，包含有 <code>rawValue</code>的值信息。<code>reflect.Value</code> 与原值间可以通过值包装和值获取互相转化。reflect.Value 是一些反射操作的重要类型，如反射调用函数。</p>
<p>从反射值对象<code>（reflect.Value）</code>中获取值的方法<br>可以通过下面几种方法从反射值对象 <code>reflect.Value</code> 中获取原值，如下表所示。</p>
<p>反射值获取原始值的方法<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Interface() <span class="keyword">interface</span> {}	将值以 <span class="keyword">interface</span>{} 类型返回，可以通过类型断言转换为指定类型</span><br><span class="line">Int() <span class="keyword">int64</span>	将值以 <span class="keyword">int</span> 类型返回，所有有符号整型均可以此方式返回</span><br><span class="line">Uint() <span class="keyword">uint64</span>	将值以 <span class="keyword">uint</span> 类型返回，所有无符号整型均可以此方式返回</span><br><span class="line">Float() <span class="keyword">float64</span>	将值以双精度（<span class="keyword">float64</span>）类型返回，所有浮点数（<span class="keyword">float32</span>、<span class="keyword">float64</span>）均可以此方式返回</span><br><span class="line">Bool() <span class="keyword">bool</span>	将值以 <span class="keyword">bool</span> 类型返回</span><br><span class="line">Bytes() []bytes	将值以字节数组 []bytes 类型返回</span><br><span class="line">String() <span class="keyword">string</span>	将值以字符串类型返回</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>例子：<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span>=<span class="number">12</span></span><br><span class="line">	t:=reflect.ValueOf(i)</span><br><span class="line">	fmt.Println(t.Interface())</span><br><span class="line">	fmt.Println(t.Int())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h4 id="通过反射访问结构体成员的值"><a href="#通过反射访问结构体成员的值" class="headerlink" title="通过反射访问结构体成员的值"></a>通过反射访问结构体成员的值</h4><blockquote>
<p>反射值对象（reflect.Value）提供对结构体访问的方法，通过这些方法可以完成对结构体任意值的访问，如下表所示。</p>
</blockquote>
<p>反射值对象的成员访问方法<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Field(i int) Value	根据索引，返回索引对应的结构体成员字段的反射值对象。当值不是结构体或索引超界时发生宕机</span><br><span class="line">NumField() int	返回结构体成员字段数量。当值不是结构体或索引超界时发生宕机</span><br><span class="line">FieldByName(name string) Value	根据给定字符串返回字符串对应的结构体字段。没有找到时返回零值，当值不是结构体或索引超界时发生宕机</span><br><span class="line">FieldByIndex(index []int) Value	多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的值。 没有找到时返回零值，当值不是结构体或索引超界时发生宕机</span><br><span class="line">FieldByNameFunc(match func(string) bool) Value	根据匹配函数匹配需要的字段。找到时返回零值，当值不是结构体或索引超界时发生宕机</span><br></pre></td></tr></tbody></table></figure><p></p>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> say <span class="keyword">struct</span>{</span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> {</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">uint</span></span><br><span class="line">	test <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	<span class="title">bool</span></span></span><br><span class="line"><span class="function">	<span class="title">method</span> <span class="title">say</span></span></span><br><span class="line"><span class="function">}</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	zhangsan := person{Name: <span class="string">"zhangsan"</span>, method: say{<span class="number">1</span>,<span class="string">"lisi"</span>}}</span><br><span class="line">	t := reflect.ValueOf(zhangsan)</span><br><span class="line">	fmt.Println(<span class="string">"Len: "</span>, t.NumField())                              <span class="comment">//字段数</span></span><br><span class="line">	fmt.Println(<span class="string">"Value: "</span>, t.Field(<span class="number">1</span>), <span class="string">"Type: "</span>, t.Field(<span class="number">1</span>).Type()) <span class="comment">//输出字段的值和类型</span></span><br><span class="line">	fmt.Println(t.FieldByName(<span class="string">"Name"</span>))                              <span class="comment">//根据名字查找字段</span></span><br><span class="line">	fmt.Println(t.FieldByIndex([]<span class="keyword">int</span>{<span class="number">0</span>}))</span><br><span class="line">	fmt.Println(<span class="string">"Value: "</span>,t.FieldByIndex([]<span class="keyword">int</span>{<span class="number">4</span>,<span class="number">1</span>}), <span class="string">"Type: "</span>,t.FieldByIndex([]<span class="keyword">int</span>{<span class="number">4</span>,<span class="number">1</span>}).Type()) <span class="comment">//[]int{4,1}中的四就是索引为4的元素，即method；1为method中索引为1的元素</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="判断反射值的空和有效性"><a href="#判断反射值的空和有效性" class="headerlink" title="判断反射值的空和有效性"></a>判断反射值的空和有效性</h4><blockquote>
<p>IsNil()和IsValid()</p>
</blockquote>
<h4 id="通过反射修改变量的值"><a href="#通过反射修改变量的值" class="headerlink" title="通过反射修改变量的值"></a>通过反射修改变量的值</h4><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用 reflect.Value 取元素、取地址及修改值的属性方法请参考下表。</span><br><span class="line">反射值对象的判定及获取元素的方法</span><br><span class="line">Elem() Value	取值指向的元素值，类似于语言层*操作。当值类型不是指针或接口时发生宕 机，空指针时返回 <span class="literal">nil</span> 的 Value</span><br><span class="line">Addr() Value	对可寻址的值返回其地址，类似于语言层&amp;操作。当值不可寻址时发生宕机</span><br><span class="line">CanAddr() <span class="keyword">bool</span>	表示值是否可寻址</span><br><span class="line">CanSet() <span class="keyword">bool</span>	返回值能否被修改。要求值可寻址且是导出的字段</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以通过调用 <code>reflect.ValueOf(&amp;x).Elem()</code>，来获取任意变量x对应的可取地址的 Value。</p>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	t:=<span class="number">1</span></span><br><span class="line">	fmt.Println(reflect.ValueOf(t).CanAddr()) <span class="comment">//false</span></span><br><span class="line">	fmt.Println(reflect.ValueOf(&amp;t).CanAddr()) <span class="comment">//false</span></span><br><span class="line">	fmt.Println(reflect.ValueOf(&amp;t).Elem().CanAddr()) <span class="comment">//true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>值修改相关方法<br>使用 <code>reflect.Value</code>修改值的相关方法如下表所示。<br>反射值对象修改值的方法<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set(x Value)	将值设置为传入的反射值对象的值</span><br><span class="line">Setlnt(x int64)	使用 int64 设置值。当值的类型不是 int、int8、int16、 int32、int64 时会发生宕机</span><br><span class="line">SetUint(x uint64)	使用 uint64 设置值。当值的类型不是 uint、uint8、uint16、uint32、uint64 时会发生宕机</span><br><span class="line">SetFloat(x float64)	使用 float64 设置值。当值的类型不是 float32、float64 时会发生宕机</span><br><span class="line">SetBool(x bool)	使用 bool 设置值。当值的类型不是 bod 时会发生宕机</span><br><span class="line">SetBytes(x []byte)	设置字节数组 []bytes值。当值的类型不是 []byte 时会发生宕机</span><br><span class="line">SetString(x string)	设置字符串值。当值的类型不是 string 时会发生宕机</span><br><span class="line">以上方法，在 reflect.Value 的 CanSet 返回 false 仍然修改值时会发生宕机。</span><br></pre></td></tr></tbody></table></figure><p></p>
<h4 id="通过反射调用函数"><a href="#通过反射调用函数" class="headerlink" title="通过反射调用函数"></a>通过反射调用函数</h4><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> {</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	funcAdd:=reflect.ValueOf(add)</span><br><span class="line">	param:=[]reflect.Value{reflect.ValueOf(<span class="number">1</span>),reflect.ValueOf(<span class="number">2</span>)}</span><br><span class="line">	result:=funcAdd.Call(param)</span><br><span class="line">	fmt.Println(result[<span class="number">0</span>].Interface())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ol>
<li>当main函数返回时，所有的<code>goroutine</code>都会退出，然后程序就退出</li>
<li><p>main函数是不会等待<code>goroutine</code>执行完的，比如如下代码没有输出A，因为还没有执行到匿名函数的<code>goroutine</code>main函数就已经结束了</p>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">        fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">    }()</span><br><span class="line">    fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Done"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>不同的<code>goroutine</code>是不会相会影响的，不如如下代码，第一个匿名函数中的sleep是不会影响第二匿名函数的<code>goroutine</code>的</p>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++{</span><br><span class="line">            fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">            time.Sleep(<span class="number">200</span> *time.Millisecond)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++{</span><br><span class="line">            fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">    time.Sleep(<span class="number">1</span> *time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"Done"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>要注意的一点是，如果主<code>goroutine</code>一直阻塞的话，会报错，但是其它<code>goroutine</code>是没有影响的，比如如下代码，最后是没有输入<code>Die</code>的，说明这个<code>goroutine</code>被一直阻塞着，但是对整个程序来说没有影响，反过来，如果是主<code>goroutine</code>阻塞了，没有接收或者发送给其它<code>goroitine</code>，那么就会报错：<code>fatal error: all goroutines are asleep - deadlock!</code>，主<code>goroutine</code>等一个永远都不会接收或者发送的数据，那么程序就会一直等下去，显然这是不允许的，所以就会报错</p>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">for</span> data := <span class="keyword">range</span> ch {</span><br><span class="line">		fmt.Println(data)</span><br><span class="line">	}</span><br><span class="line">	fmt.Println(<span class="string">"Die"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">	<span class="keyword">go</span> test()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++ {</span><br><span class="line">		ch &lt;- i</span><br><span class="line">	}</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	data := <span class="number">10</span></span><br><span class="line">	<span class="keyword">if</span> data == <span class="number">10</span> {</span><br><span class="line">		fmt.Println(<span class="string">"Done"</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<p>带缓冲通道的阻塞条件<br>带缓冲通道在很多特性上和无缓冲通道是类似的。无缓冲通道可以看作是长度永远为 0 的带缓冲通道。因此根据这个特性，带缓冲通道在下面列举的情况下依然会发生阻塞：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">带缓冲通道被填满时，尝试再次发送数据时发生阻塞。</span><br><span class="line">带缓冲通道为空时，尝试接收数据时发生阻塞。</span><br></pre></td></tr></tbody></table></figure><p></p>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    Sendch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    Sendch &lt;<span class="number">-1</span></span><br><span class="line">    Sendch &lt;<span class="number">-2</span></span><br><span class="line">    Sendch &lt;<span class="number">-3</span></span><br><span class="line">    fmt.Println(<span class="string">"len:"</span>,<span class="built_in">len</span>(Sendch))</span><br><span class="line">    fmt.Println(&lt;-Sendch)</span><br><span class="line">    <span class="comment">//Sendch &lt;-4 这个时候如果再往通道里面放数据，就会阻塞</span></span><br><span class="line">    <span class="keyword">for</span> data:=<span class="keyword">range</span> Sendch{</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">        <span class="keyword">if</span> data==<span class="number">3</span>{</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(<span class="string">"len:"</span>,<span class="built_in">len</span>(Sendch))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通道的超时机制</p>
<blockquote>
<p>配合select机制</p>
</blockquote>
<p>如果有一个或多个IO操作可以完成，则Go运行时系统会随机的选择一个执行，否则的话，如果有default分支，则执行default分支语句，如果连default都没有，则select语句会一直阻塞，直到至少有一个IO操作可以进行.</p>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</span><br><span class="line">    timeout:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">        time.Sleep(<span class="number">3</span> *time.Second)</span><br><span class="line">        timeout&lt;-<span class="literal">true</span></span><br><span class="line">    }()</span><br><span class="line">    <span class="keyword">select</span>{</span><br><span class="line">        <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">            fmt.Println(<span class="string">"No timeout"</span>)</span><br><span class="line">        <span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">            fmt.Println(<span class="string">"timeout"</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"default"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span></span><br><span class="line">因为前面的ch和timeout的通道都没有接收到数据，所以默认会执行<span class="keyword">default</span></span><br></pre></td></tr></tbody></table></figure>
<p>1). 如果我们把上面的default注释掉的话，会怎么样呢，会输出<code>timeout</code>，因为没有了default语句，如果其它通道一直接收到数据的话就会一直阻塞，直到有其它<code>goroutine</code>给它发送数据，上面的匿名<code>goroutine</code>sleep 3秒之后就会给通道<code>timeout</code>发送数据，所以就会输出<code>timeout</code></p>
<p>2). 那如果我们把上面代码改为如下代码会输出什么呢<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// import "time"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</span><br><span class="line">    timeout:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">        timeout&lt;-<span class="literal">true</span></span><br><span class="line">        ch&lt;<span class="number">-1</span></span><br><span class="line">    }()</span><br><span class="line">    fmt.Println(<span class="string">"main goroutine begin"</span>)</span><br><span class="line">    <span class="keyword">select</span>{</span><br><span class="line">        <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">            fmt.Println(<span class="string">"No timeout"</span>)</span><br><span class="line">        <span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">            fmt.Println(<span class="string">"timeout"</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"default"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">output</span><br><span class="line">会随机输出timeout、No timeout和<span class="keyword">default</span>，因为所有通道都满足<span class="keyword">case</span>，则<span class="keyword">go</span>运行的时候会随机选择一个<span class="keyword">case</span>执行</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>简单模拟一下客户端服务端通信<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Client</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">interface</span>{}, content <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>{}, error)</span></span> {</span><br><span class="line">	ch &lt;- content</span><br><span class="line">	<span class="keyword">select</span> {</span><br><span class="line">	<span class="keyword">case</span> resp := &lt;-ch:</span><br><span class="line">		<span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"time out"</span>)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Server</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">interface</span>{}, content <span class="keyword">string</span>)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>{</span><br><span class="line">        data:=&lt;-ch</span><br><span class="line">        fmt.Println(<span class="string">"received:"</span>,data)</span><br><span class="line">        <span class="comment">// time.Sleep(3 *time.Second) 如果想模拟超时可以加上这条代码</span></span><br><span class="line">        ch&lt;-content</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>{})</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> Server(ch,<span class="string">"Send data"</span>)</span><br><span class="line">    recv,err:=Client(ch,<span class="string">"hello"</span>)</span><br><span class="line">    <span class="keyword">if</span> err!=<span class="literal">nil</span>{</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        fmt.Println(recv)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>通道响应计时器</p>
<p>1). 延时回调<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    IsExit:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Start"</span>)</span><br><span class="line">    time.AfterFunc(<span class="number">2</span> * time.Second,<span class="function"><span class="keyword">func</span><span class="params">()</span></span>{</span><br><span class="line">        fmt.Println(<span class="string">"Exec"</span>)</span><br><span class="line">        IsExit&lt;-<span class="literal">true</span></span><br><span class="line">    })</span><br><span class="line">    &lt;-IsExit</span><br><span class="line">    fmt.Println(<span class="string">"Exit"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line">Start</span><br><span class="line">Exec</span><br><span class="line">Exit</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>2). 定点计时<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ticker := time.NewTicker(<span class="number">200</span> * time.Millisecond) <span class="comment">//创建一个打点器，每200毫秒触发一次</span></span><br><span class="line">    breaker:= time.NewTimer(<span class="number">3</span> * time.Second)    <span class="comment">//创建一个计时器，3秒后触发一次</span></span><br><span class="line">    <span class="keyword">var</span> stop <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span>{</span><br><span class="line">        <span class="keyword">select</span>{</span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            count++</span><br><span class="line">        <span class="keyword">case</span> &lt;-breaker.C:</span><br><span class="line">            fmt.Println(<span class="string">"Time out break"</span>)</span><br><span class="line">            stop=<span class="literal">true</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> stop{</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">//如果breaker通道接收到数据则退出</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    fmt.Println(count)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>从已经关闭中的通道获取数据</p>
<ol>
<li>关闭的通道依然可以被访问，访问被关闭的通道将会发生一些问题。</li>
<li>被关闭的通道不会被置为 nil</li>
<li>如果尝试对已经关闭的通道进行发送，将会触发宕机</li>
</ol>
<p>从已经关闭的通道接收数据或者正在接收数据时，将会接收到通道类型的零值，然后停止阻塞并返回，如下代码<br></p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">2</span>)</span><br><span class="line">    ch&lt;<span class="number">-1</span></span><br><span class="line">    ch&lt;<span class="number">-2</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=<span class="built_in">cap</span>(ch);i++{</span><br><span class="line">        data,ok:=&lt;-ch</span><br><span class="line">        fmt.Println(data,ok)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"><span class="number">1</span> <span class="literal">true</span></span><br><span class="line"><span class="number">2</span> <span class="literal">true</span></span><br><span class="line"><span class="number">0</span> <span class="literal">false</span> <span class="comment">//false 表示没有获取成功，因为此时通道已经空了</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="活锁、死锁、饥饿"><a href="#活锁、死锁、饥饿" class="headerlink" title="活锁、死锁、饥饿"></a>活锁、死锁、饥饿</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote>
<p>死锁：会使得所有并发程序在等待，如果没有外界干预，程序不能恢复</p>
</blockquote>
<figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>出现死锁的几个必要条件，也被称为<code>Coffman</code>条件</p>
<p><code>Coffman</code> 条件如下：</p>
<ol>
<li>相互排斥：井发进程同时拥有资源的独占权。</li>
<li>等待条件：并发进程必须同时拥有一个资源，并等待额外的资源。</li>
<li>没有抢占：并发进程拥有的资掘只能被该进程释放，即可满足这个条件。</li>
<li>循环等待：一个并发进程（P1）必须等待一系列其他井发进程（P2），这些并发进程同时也在等待进程（P2），这样便满足了这个最终条件。</li>
</ol>
<h3 id="一些杂项"><a href="#一些杂项" class="headerlink" title="一些杂项"></a>一些杂项</h3><h4 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h4><p>获取包：<code>go get github.com/skip2/go-qrcode</code></p>
<p>生成一个跳转到百度的二维码<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import "github.com/skip2/go-qrcode"</span><br><span class="line">func main() {</span><br><span class="line">    qrcode.WriteFile("http://www.baidu.com/",qrcode.Medium,256,"./qrcode.png")</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-12-22T14:26:45.048Z" itemprop="dateUpdated">2019-12-22 22:26:45</time>
</span><br>


        
        know it then hack it
        
    </div>
    
    <footer>
        <a href="https://byqiyou.github.io">
            <img src="/img/avatar.jpg" alt="">
            
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/">Golang</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://byqiyou.github.io/2019/11/15/Golang学习笔记/&title=《Golang学习笔记》 — 七友&pic=https://byqiyou.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://byqiyou.github.io/2019/11/15/Golang学习笔记/&title=《Golang学习笔记》 — 七友&source=路漫漫其修远兮，吾将上下而求索" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://byqiyou.github.io/2019/11/15/Golang学习笔记/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Golang学习笔记》 — 七友&url=https://byqiyou.github.io/2019/11/15/Golang学习笔记/&via=https://byqiyou.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://byqiyou.github.io/2019/11/15/Golang学习笔记/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/12/19/golang指针类型转换上遇到的一些问题/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">golang指针类型转换上遇到的一些问题</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/10/02/windows中常见后门持久化方法总结/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">windows中常见后门持久化方法总结</h4>
      </a>
    </div>
  
</nav>



    


<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'true';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>




<section class="comments" id="comments">
    <!-- UY BEGIN -->
    <div id="uyan_frame"></div>
    <script src="http://v2.uyan.cc/code/uyan.js?uid=true"></script>
    <!-- UY END -->
</section>
















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        Thinks
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/2.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/2.png" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span> &copy; 2018 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://byqiyou.github.io/2019/11/15/Golang学习笔记/&title=《Golang学习笔记》 — 七友&pic=https://byqiyou.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://byqiyou.github.io/2019/11/15/Golang学习笔记/&title=《Golang学习笔记》 — 七友&source=路漫漫其修远兮，吾将上下而求索" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://byqiyou.github.io/2019/11/15/Golang学习笔记/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Golang学习笔记》 — 七友&url=https://byqiyou.github.io/2019/11/15/Golang学习笔记/&via=https://byqiyou.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://byqiyou.github.io/2019/11/15/Golang学习笔记/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://byqiyou.github.io/2019/11/15/Golang学习笔记/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'Leave';
            clearTimeout(titleTime);
        } else {
            document.title = 'Come back';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
